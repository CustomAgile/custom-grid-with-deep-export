<!DOCTYPE html>
<html>
<head>
    <title>custom-grid-with-deep-export-1.3.11</title>
    <!--  (c) 2019 Custom Agile.  All Rights Reserved. -->
    <!--  Build Date: Thu Aug 08 2019 18:16:06 GMT-0500 (Central Daylight Time) -->

    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Aug 08 2019 18:16:06 GMT-0500 (Central Daylight Time)";
        var CHECKSUM = 1020791361128;
    </script>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
var CustomAgile=function(e){var t={};function n(r){if(t[r])return t[r].exports;var s=t[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)n.d(r,s,function(t){return e[t]}.bind(null,s));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=7)}([function(e,t,n){"use strict";t.load=function(e,t,n={}){var r,s,i;for(r in t)i=t[r],n[r]=null!=(s=e[r])?s:i;return n},t.overwrite=function(e,t,n={}){var r,s;for(r in e)s=e[r],void 0!==t[r]&&(n[r]=s);return n}},function(e,t,n){"use strict";function r(e,t,n,r,s,i,o){try{var a=e[i](o),c=a.value}catch(e){return void n(e)}a.done?t(c):Promise.resolve(c).then(r,s)}function s(e){return function(){var t=this,n=arguments;return new Promise(function(s,i){var o=e.apply(t,n);function a(e){r(o,s,i,a,c,"next",e)}function c(e){r(o,s,i,a,c,"throw",e)}a(void 0)})}}var i;i=class{constructor(e){if(this.instance=e,this._events={},null!=this.instance.on||null!=this.instance.once||null!=this.instance.removeAllListeners)throw new Error("An Emitter already exists for this object");this.instance.on=(e,t)=>this._addListener(e,"many",t),this.instance.once=(e,t)=>this._addListener(e,"once",t),this.instance.removeAllListeners=(e=null)=>null!=e?delete this._events[e]:this._events={}}_addListener(e,t,n){var r;return null==(r=this._events)[e]&&(r[e]=[]),this._events[e].push({cb:n,status:t}),this.instance}listenerCount(e){return null!=this._events[e]?this._events[e].length:0}trigger(e,...t){var n=this;return s(function*(){var r,i;try{if("debug"!==e&&n.trigger("debug",`Event triggered: ${e}`,t),null==n._events[e])return;return n._events[e]=n._events[e].filter(function(e){return"none"!==e.status}),i=n._events[e].map(function(){var e=s(function*(e){var r,s;if("none"!==e.status){"once"===e.status&&(e.status="none");try{return"function"==typeof(null!=(s="function"==typeof e.cb?e.cb(...t):void 0)?s.then:void 0)?yield s:s}catch(e){return r=e,n.trigger("error",r),null}}});return function(t){return e.apply(this,arguments)}}()),(yield Promise.all(i)).find(function(e){return null!=e})}catch(e){return r=e,n.trigger("error",r),null}})()}},e.exports=i},function(e,t,n){"use strict";var r;r=class extends Error{},e.exports=r},function(e,t){e.exports=_},function(module,exports,__webpack_require__){"use strict";function asyncGeneratorStep(e,t,n,r,s,i,o){try{var a=e[i](o),c=a.value}catch(e){return void n(e)}a.done?t(c):Promise.resolve(c).then(r,s)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise(function(r,s){var i=e.apply(t,n);function o(e){asyncGeneratorStep(i,r,s,o,a,"next",e)}function a(e){asyncGeneratorStep(i,r,s,o,a,"throw",e)}o(void 0)})}}var Events,RedisConnection,Scripts,parser;parser=__webpack_require__(0),Events=__webpack_require__(1),Scripts=__webpack_require__(5),RedisConnection=function(){class RedisConnection{constructor(options={}){var Redis;Redis=eval("require")("redis"),parser.load(options,this.defaults,this),null==this.Events&&(this.Events=new Events(this)),this.terminated=!1,null==this.client&&(this.client=Redis.createClient(this.clientOptions)),this.subscriber=this.client.duplicate(),this.limiters={},this.shas={},this.ready=this.Promise.all([this._setup(this.client,!1),this._setup(this.subscriber,!0)]).then(()=>this._loadScripts()).then(()=>({client:this.client,subscriber:this.subscriber}))}_setup(e,t){return e.setMaxListeners(0),new this.Promise((n,r)=>(e.on("error",e=>this.Events.trigger("error",e)),t&&e.on("message",(e,t)=>{var n;return null!=(n=this.limiters[e])?n._store.onMessage(e,t):void 0}),e.ready?n():e.once("ready",n)))}_loadScript(e){return new this.Promise((t,n)=>{var r;return r=Scripts.payload(e),this.client.multi([["script","load",r]]).exec((r,s)=>null!=r?n(r):(this.shas[e]=s[0],t(s[0])))})}_loadScripts(){return this.Promise.all(Scripts.names.map(e=>this._loadScript(e)))}__runCommand__(e){var t=this;return _asyncToGenerator(function*(){return yield t.ready,new t.Promise((n,r)=>t.client.multi([e]).exec_atomic(function(e,t){return null!=e?r(e):n(t[0])}))})()}__addLimiter__(e){return this.Promise.all([e.channel(),e.channel_client()].map(t=>new this.Promise((n,r)=>{var s;return s=r=>{if(r===t)return this.subscriber.removeListener("subscribe",s),this.limiters[t]=e,n()},this.subscriber.on("subscribe",s),this.subscriber.subscribe(t)})))}__removeLimiter__(e){var t=this;return this.Promise.all([e.channel(),e.channel_client()].map(function(){var e=_asyncToGenerator(function*(e){return t.terminated||(yield new t.Promise((n,r)=>t.subscriber.unsubscribe(e,function(t,s){return null!=t?r(t):s===e?n():void 0}))),delete t.limiters[e]});return function(t){return e.apply(this,arguments)}}()))}__scriptArgs__(e,t,n,r){var s;return s=Scripts.keys(e,t),[this.shas[e],s.length].concat(s,n,r)}__scriptFn__(e){return this.client.evalsha.bind(this.client)}disconnect(e=!0){var t,n,r,s;for(t=0,r=(s=Object.keys(this.limiters)).length;t<r;t++)n=s[t],clearInterval(this.limiters[n]._store.heartbeat);return this.limiters={},this.terminated=!0,this.client.end(e),this.subscriber.end(e),this.Promise.resolve()}}return RedisConnection.prototype.datastore="redis",RedisConnection.prototype.defaults={clientOptions:{},client:null,Promise:Promise,Events:null},RedisConnection}.call(void 0),module.exports=RedisConnection},function(e,t,n){"use strict";var r,s,i;s=n(20),r={refs:s["refs.lua"],validate_keys:s["validate_keys.lua"],validate_client:s["validate_client.lua"],refresh_expiration:s["refresh_expiration.lua"],process_tick:s["process_tick.lua"],conditions_check:s["conditions_check.lua"],get_time:s["get_time.lua"]},t.allKeys=function(e){return[`b_${e}_settings`,`b_${e}_job_weights`,`b_${e}_job_expirations`,`b_${e}_job_clients`,`b_${e}_client_running`,`b_${e}_client_num_queued`,`b_${e}_client_last_registered`,`b_${e}_client_last_seen`]},i={init:{keys:t.allKeys,headers:["process_tick"],refresh_expiration:!0,code:s["init.lua"]},group_check:{keys:t.allKeys,headers:[],refresh_expiration:!1,code:s["group_check.lua"]},register_client:{keys:t.allKeys,headers:["validate_keys"],refresh_expiration:!1,code:s["register_client.lua"]},blacklist_client:{keys:t.allKeys,headers:["validate_keys","validate_client"],refresh_expiration:!1,code:s["blacklist_client.lua"]},heartbeat:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:s["heartbeat.lua"]},update_settings:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:s["update_settings.lua"]},running:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:s["running.lua"]},queued:{keys:t.allKeys,headers:["validate_keys","validate_client"],refresh_expiration:!1,code:s["queued.lua"]},done:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:s["done.lua"]},check:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!1,code:s["check.lua"]},submit:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!0,code:s["submit.lua"]},register:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!0,code:s["register.lua"]},free:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:s["free.lua"]},current_reservoir:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:s["current_reservoir.lua"]},increment_reservoir:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:s["increment_reservoir.lua"]}},t.names=Object.keys(i),t.keys=function(e,t){return i[e].keys(t)},t.payload=function(e){var t;return t=i[e],Array.prototype.concat(r.refs,t.headers.map(function(e){return r[e]}),t.refresh_expiration?r.refresh_expiration:"",t.code).join("\n")}},function(module,exports,__webpack_require__){"use strict";function _slicedToArray(e,t){return _arrayWithHoles(e)||_iterableToArrayLimit(e,t)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(e,t){var n=[],r=!0,s=!1,i=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){s=!0,i=e}finally{try{r||null==a.return||a.return()}finally{if(s)throw i}}return n}function _arrayWithHoles(e){if(Array.isArray(e))return e}function asyncGeneratorStep(e,t,n,r,s,i,o){try{var a=e[i](o),c=a.value}catch(e){return void n(e)}a.done?t(c):Promise.resolve(c).then(r,s)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise(function(r,s){var i=e.apply(t,n);function o(e){asyncGeneratorStep(i,r,s,o,a,"next",e)}function a(e){asyncGeneratorStep(i,r,s,o,a,"throw",e)}o(void 0)})}}var Events,IORedisConnection,Scripts,parser;parser=__webpack_require__(0),Events=__webpack_require__(1),Scripts=__webpack_require__(5),IORedisConnection=function(){class IORedisConnection{constructor(options={}){var Redis;Redis=eval("require")("ioredis"),parser.load(options,this.defaults,this),null==this.Events&&(this.Events=new Events(this)),this.terminated=!1,null!=this.clusterNodes?(this.client=new Redis.Cluster(this.clusterNodes,this.clientOptions),this.subscriber=new Redis.Cluster(this.clusterNodes,this.clientOptions)):(null==this.client&&(this.client=new Redis(this.clientOptions)),this.subscriber=this.client.duplicate()),this.limiters={},this.ready=this.Promise.all([this._setup(this.client,!1),this._setup(this.subscriber,!0)]).then(()=>(this._loadScripts(),{client:this.client,subscriber:this.subscriber}))}_setup(e,t){return e.setMaxListeners(0),new this.Promise((n,r)=>(e.on("error",e=>this.Events.trigger("error",e)),t&&e.on("message",(e,t)=>{var n;return null!=(n=this.limiters[e])?n._store.onMessage(e,t):void 0}),"ready"===e.status?n():e.once("ready",n)))}_loadScripts(){return Scripts.names.forEach(e=>this.client.defineCommand(e,{lua:Scripts.payload(e)}))}__runCommand__(e){var t=this;return _asyncToGenerator(function*(){yield t.ready;var n=_slicedToArray(yield t.client.pipeline([e]).exec(),1),r=_slicedToArray(n[0],2);return r[0],r[1]})()}__addLimiter__(e){return this.Promise.all([e.channel(),e.channel_client()].map(t=>new this.Promise((n,r)=>this.subscriber.subscribe(t,()=>(this.limiters[t]=e,n())))))}__removeLimiter__(e){var t=this;return[e.channel(),e.channel_client()].forEach(function(){var e=_asyncToGenerator(function*(e){return t.terminated||(yield t.subscriber.unsubscribe(e)),delete t.limiters[e]});return function(t){return e.apply(this,arguments)}}())}__scriptArgs__(e,t,n,r){var s;return[(s=Scripts.keys(e,t)).length].concat(s,n,r)}__scriptFn__(e){return this.client[e].bind(this.client)}disconnect(e=!0){var t,n,r,s;for(t=0,r=(s=Object.keys(this.limiters)).length;t<r;t++)n=s[t],clearInterval(this.limiters[n]._store.heartbeat);return this.limiters={},this.terminated=!0,e?this.Promise.all([this.client.quit(),this.subscriber.quit()]):(this.client.disconnect(),this.subscriber.disconnect(),this.Promise.resolve())}}return IORedisConnection.prototype.datastore="ioredis",IORedisConnection.prototype.defaults={clientOptions:{},clusterNodes:null,client:null,Promise:Promise,Events:null},IORedisConnection}.call(void 0),module.exports=IORedisConnection},function(e,t,n){"use strict";function r(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),r(n(12)),r(n(26)),r(n(8)),r(n(27)),r(n(9))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(3),s="[0-9]+|-?[0-9]+|[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}|[a-fA-F0-9]{32}",i=`(${s})`,o=`(?:${s})`,a="(?:\\.js\\??.*)",c=[new RegExp(`.*?\\/(\\w{2,}\\/\\w+)\\/${i}\\/(\\w+)${a}?$`),new RegExp(`.*?\\/(\\w{2,}\\/\\w+)\\/${i}${a}?$`),new RegExp(`.*?\\/(\\w+)\\/${i}\\/(\\w+)${a}?$`),new RegExp(`.*?\\/(\\w+)\\/${i}${a}?$`),new RegExp(`.*?\\/(\\w+)\\/(${o}u${o}[pw]${o})${a}?$`)];function l(e){e=e&&e._ref?e._ref:e||"";const t=r.find(c,t=>t.test(e));return t&&e.match(t)||null}t.Ref=class{static isRef(e){return Boolean(l(e))}static getRelative(e){const t=l(e);return t&&[""].concat(t.slice(1)).join("/")||null}static getType(e){const t=l(e);return t&&t[1]||null}static getId(e){const t=l(e);return t&&t[2]||null}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(15);t.Throttle=class{constructor(e=10,t=5){this.maxPromises=e,this.bottleneck=new r.default({maxConcurrent:e})}async queueAction(e,t=0){try{return await this.bottleneck.wrap(e)()}catch(n){if(t>0)return this.queueAction(e,--t);throw n}}}},function(e,t,n){"use strict";function r(e,t){return o(e)||function(e,t){var n=[],r=!0,s=!1,i=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){s=!0,i=e}finally{try{r||null==a.return||a.return()}finally{if(s)throw i}}return n}(e,t)||i()}function s(e){return o(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function o(e){if(Array.isArray(e))return e}function a(e,t,n,r,s,i,o){try{var a=e[i](o),c=a.value}catch(e){return void n(e)}a.done?t(c):Promise.resolve(c).then(r,s)}function c(e){return function(){var t=this,n=arguments;return new Promise(function(r,s){var i=e.apply(t,n);function o(e){a(i,r,s,o,c,"next",e)}function c(e){a(i,r,s,o,c,"throw",e)}o(void 0)})}}var l,u,h,d,_,p,v,y,f,m,g=[].splice;_=10,m=n(0),p=n(16),h=n(17),d=n(18),v=n(19),u=n(1),y=n(21),f=n(22),l=function(){class e{constructor(t={},...n){var r,s;this._addToQueue=this._addToQueue.bind(this),this._validateOptions(t,n),m.load(t,this.instanceDefaults,this),this._queues=new p(_),this._scheduled={},this._states=new y(["RECEIVED","QUEUED","RUNNING","EXECUTING"].concat(this.trackDoneStatus?["DONE"]:[])),this._limiter=null,this.Events=new u(this),this._submitLock=new f("submit",this.Promise),this._registerLock=new f("register",this.Promise),s=m.load(t,this.storeDefaults,{}),this._store=function(){if("redis"===this.datastore||"ioredis"===this.datastore||null!=this.connection)return r=m.load(t,this.redisStoreDefaults,{}),new v(this,s,r);if("local"===this.datastore)return r=m.load(t,this.localStoreDefaults,{}),new d(this,s,r);throw new e.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`)}.call(this),this._queues.on("leftzero",()=>{var e;return"function"==typeof(e=this._store.heartbeat).ref?e.ref():void 0}),this._queues.on("zero",()=>{var e;return"function"==typeof(e=this._store.heartbeat).unref?e.unref():void 0})}_validateOptions(t,n){if(null==t||"object"!=typeof t||0!==n.length)throw new e.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.")}ready(){return this._store.ready}clients(){return this._store.clients}channel(){return`b_${this.id}`}channel_client(){return`b_${this.id}_${this._store.clientId}`}publish(e){return this._store.__publish__(e)}disconnect(e=!0){return this._store.__disconnect__(e)}chain(e){return this._limiter=e,this}queued(e){return this._queues.queued(e)}clusterQueued(){return this._store.__queued__()}empty(){return 0===this.queued()&&this._submitLock.isEmpty()}running(){return this._store.__running__()}done(){return this._store.__done__()}jobStatus(e){return this._states.jobStatus(e)}jobs(e){return this._states.statusJobs(e)}counts(){return this._states.statusCounts()}_randomIndex(){return Math.random().toString(36).slice(2)}check(e=1){return this._store.__check__(e)}_clearGlobalState(e){return null!=this._scheduled[e]&&(clearTimeout(this._scheduled[e].expiration),delete this._scheduled[e],!0)}_free(e,t,n,r){var s=this;return c(function*(){var t,i;try{if(i=(yield s._store.__free__(e,n.weight)).running,s.Events.trigger("debug",`Freed ${n.id}`,r),0===i&&s.empty())return s.Events.trigger("idle")}catch(e){return t=e,s.Events.trigger("error",t)}})()}_run(e,t,n){var r,s,i;return t.doRun(),r=this._clearGlobalState.bind(this,e),i=this._run.bind(this,e,t),s=this._free.bind(this,e,t),this._scheduled[e]={timeout:setTimeout(()=>t.doExecute(this._limiter,r,i,s),n),expiration:null!=t.options.expiration?setTimeout(function(){return t.doExpire(r,i,s)},n+t.options.expiration):void 0,job:t}}_drainOne(e){return this._registerLock.schedule(()=>{var t,n,r,s,i;if(0===this.queued())return this.Promise.resolve(null);i=this._queues.getFirst();var o=r=i.first();return s=o.options,t=o.args,null!=e&&s.weight>e?this.Promise.resolve(null):(this.Events.trigger("debug",`Draining ${s.id}`,{args:t,options:s}),n=this._randomIndex(),this._store.__register__(n,s.weight,s.expiration).then(({success:e,wait:o,reservoir:a})=>{var c;return this.Events.trigger("debug",`Drained ${s.id}`,{success:e,args:t,options:s}),e?(i.shift(),(c=this.empty())&&this.Events.trigger("empty"),0===a&&this.Events.trigger("depleted",c),this._run(n,r,o),this.Promise.resolve(s.weight)):this.Promise.resolve(null)}))})}_drainAll(e,t=0){return this._drainOne(e).then(n=>{var r;return null!=n?(r=null!=e?e-n:e,this._drainAll(r,t+n)):this.Promise.resolve(t)}).catch(e=>this.Events.trigger("error",e))}_dropAllQueued(e){return this._queues.shiftAll(function(t){return t.doDrop({message:e})})}stop(t={}){var n,r;return t=m.load(t,this.stopDefaults),r=e=>{var t;return t=()=>{var t;return(t=this._states.counts)[0]+t[1]+t[2]+t[3]===e},new this.Promise((e,n)=>t()?e():this.on("done",()=>{if(t())return this.removeAllListeners("done"),e()}))},n=t.dropWaitingJobs?(this._run=function(e,n){return n.doDrop({message:t.dropErrorMessage})},this._drainOne=()=>this.Promise.resolve(null),this._registerLock.schedule(()=>this._submitLock.schedule(()=>{var e,n,s;for(e in n=this._scheduled)s=n[e],"RUNNING"===this.jobStatus(s.job.options.id)&&(clearTimeout(s.timeout),clearTimeout(s.expiration),s.job.doDrop({message:t.dropErrorMessage}));return this._dropAllQueued(t.dropErrorMessage),r(0)}))):this.schedule({priority:_-1,weight:0},()=>r(1)),this._receive=function(n){return n._reject(new e.prototype.BottleneckError(t.enqueueErrorMessage))},this.stop=()=>this.Promise.reject(new e.prototype.BottleneckError("stop() has already been called")),n}_addToQueue(t){var n=this;return c(function*(){var r,s,i,o,a,c,l;r=t.args,o=t.options;try{var u=yield n._store.__submit__(n.queued(),o.weight);a=u.reachedHWM,s=u.blocked,l=u.strategy}catch(e){return i=e,n.Events.trigger("debug",`Could not queue ${o.id}`,{args:r,options:o,error:i}),t.doDrop({error:i}),!1}return s?(t.doDrop(),!0):a&&(null!=(c=l===e.prototype.strategy.LEAK?n._queues.shiftLastFrom(o.priority):l===e.prototype.strategy.OVERFLOW_PRIORITY?n._queues.shiftLastFrom(o.priority+1):l===e.prototype.strategy.OVERFLOW?t:void 0)&&c.doDrop(),null==c||l===e.prototype.strategy.OVERFLOW)?(null==c&&t.doDrop(),a):(t.doQueue(a,s),n._queues.push(t),yield n._drainAll(),a)})()}_receive(t){return null!=this._states.jobStatus(t.options.id)?(t._reject(new e.prototype.BottleneckError(`A job with the same id already exists (id=${t.options.id})`)),!1):(t.doReceive(),this._submitLock.schedule(this._addToQueue,t))}submit(...e){var t,n,i,o,a,c,l,u;"function"==typeof e[0]?(a=s(e),n=a[0],e=a.slice(1),c=r(g.call(e,-1),1),t=c[0],o=m.load({},this.jobDefaults)):(o=(l=s(e))[0],n=l[1],e=l.slice(2),u=r(g.call(e,-1),1),t=u[0],o=m.load(o,this.jobDefaults));return(i=new h((...e)=>new this.Promise(function(t,r){return n(...e,function(...e){return(null!=e[0]?r:t)(e)})}),e,o,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise)).promise.then(function(e){return"function"==typeof t?t(...e):void 0}).catch(function(e){return Array.isArray(e)?"function"==typeof t?t(...e):void 0:"function"==typeof t?t(e):void 0}),this._receive(i)}schedule(...e){var t,n,r;if("function"==typeof e[0]){var i=s(e);r=i[0],e=i.slice(1),n={}}else{var o=s(e);n=o[0],r=o[1],e=o.slice(2)}return t=new h(r,e,n,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise),this._receive(t),t.promise}wrap(e){var t,n;return t=this.schedule.bind(this),(n=function(...n){return t(e.bind(this),...n)}).withOptions=function(n,...r){return t(n,e,...r)},n}updateSettings(e={}){var t=this;return c(function*(){return yield t._store.__updateSettings__(m.overwrite(e,t.storeDefaults)),m.overwrite(e,t.instanceDefaults,t),t})()}currentReservoir(){return this._store.__currentReservoir__()}incrementReservoir(e=0){return this._store.__incrementReservoir__(e)}}return e.default=e,e.Events=u,e.version=e.prototype.version=n(23).version,e.strategy=e.prototype.strategy={LEAK:1,OVERFLOW:2,OVERFLOW_PRIORITY:4,BLOCK:3},e.BottleneckError=e.prototype.BottleneckError=n(2),e.Group=e.prototype.Group=n(24),e.RedisConnection=e.prototype.RedisConnection=n(4),e.IORedisConnection=e.prototype.IORedisConnection=n(6),e.Batcher=e.prototype.Batcher=n(25),e.prototype.jobDefaults={priority:5,weight:1,expiration:null,id:"<no-id>"},e.prototype.storeDefaults={maxConcurrent:null,minTime:0,highWater:null,strategy:e.prototype.strategy.LEAK,penalty:null,reservoir:null,reservoirRefreshInterval:null,reservoirRefreshAmount:null,reservoirIncreaseInterval:null,reservoirIncreaseAmount:null,reservoirIncreaseMaximum:null},e.prototype.localStoreDefaults={Promise:Promise,timeout:null,heartbeatInterval:250},e.prototype.redisStoreDefaults={Promise:Promise,timeout:null,heartbeatInterval:5e3,clientTimeout:1e4,clientOptions:{},clusterNodes:null,clearDatastore:!1,connection:null},e.prototype.instanceDefaults={datastore:"local",connection:null,id:"<no-id>",rejectOnDrop:!0,trackDoneStatus:!1,Promise:Promise},e.prototype.stopDefaults={enqueueErrorMessage:"This limiter has been stopped and cannot accept new jobs.",dropWaitingJobs:!0,dropErrorMessage:"This limiter has been stopped."},e}.call(void 0),e.exports=l},function(e,t,n){"use strict";var r;r=class{constructor(e,t){this.incr=e,this.decr=t,this._first=null,this._last=null,this.length=0}push(e){var t;this.length++,"function"==typeof this.incr&&this.incr(),t={value:e,prev:this._last,next:null},null!=this._last?(this._last.next=t,this._last=t):this._first=this._last=t}shift(){var e;if(null!=this._first)return this.length--,"function"==typeof this.decr&&this.decr(),e=this._first.value,null!=(this._first=this._first.next)?this._first.prev=null:this._last=null,e}first(){if(null!=this._first)return this._first.value}getArray(){var e,t,n;for(e=this._first,n=[];null!=e;)n.push((t=e,e=e.next,t.value));return n}forEachShift(e){var t;for(t=this.shift();null!=t;)e(t),t=this.shift()}debug(){var e,t,n,r,s;for(e=this._first,s=[];null!=e;)s.push((t=e,e=e.next,{value:t.value,prev:null!=(n=t.prev)?n.value:void 0,next:null!=(r=t.next)?r.value:void 0}));return s}},e.exports=r},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(13),s=n(3),i=n(14),o=n(8),a=n(9),c=r;let l=!1,u=i;i.URLSearchParams&&(l=!0,u=i.URLSearchParams||i);class h{constructor(e,t={server:h.defaultRallyServer,project:void 0,workspace:void 0,maxConcurrentRequests:5,maxReadRetrys:5,maxWriteRetrys:0}){if(!s.isString(e)&&!l)throw new Error("Api key is required");this.options=s.defaults(t,{server:h.defaultRallyServer,project:void 0,workspace:void 0,maxConcurrentRequests:5,maxReadRetrys:5,maxWriteRetrys:0}),this.options.server=t.server||h.defaultRallyServer,this.apiKey=e,this.workspace=t.workspace,this.project=t.project,this.throttle=new a.Throttle(this.options.maxConcurrentRequests)}static get defaultRallyServer(){return"https://rally1.rallydev.com"}static async manageResponse(e){if(!e.ok)throw new Error(`${e.statusText} Code:${e.status}`);const t=await e.json(),n=t[s.keys(t)[0]]||"",r=n.Errors||t.Errors;if(r&&r.length)throw new Error(r.map(e=>`Rally Server Error: ${e}`).join(","));let i=t;return t.QueryResult?(i=t.QueryResult.Results,t.TotalResultCount=t.QueryResult.TotalResultCount,t.PageSize=t.QueryResult.PageSize,delete t.QueryResult):t.Results?(i=t.Results,delete t.Results):n.Object&&(i=n.Object,delete t.Object),i.$rawResponse=t,i}async queryLookback(e,t=0){const n=t?`/workspace/${t}`:this.workspace,r=`${this.options.server}/analytics/v2.0/service/rally${n}/artifact/snapshot/query`,i=s.defaults(e,h.defaultLookbackRequest);let o={};this.apiKey&&(o.zsessionid=this.apiKey);const a=JSON.stringify(e,null,2),l=await this.throttle.queueAction(async()=>{const e=await c(r,{method:"POST",mode:"cors",headers:o,credentials:"include",body:a},this.options.maxReadRetrys);return await h.manageResponse(e)},this.options.maxReadRetrys);l.$params=i,l.$hasMore=l.$rawResponse.HasMore;const u=l.$rawResponse;return l.$getNextPage=async()=>{if(l.$hasMore){const n=s.cloneDeep(e);return n.start+=n.pagesize,this.queryLookback(n,t)}throw new Error("No more pages in this request")},l.$getAll=async()=>{let e=l;e.$hasMore=l.$hasMore;let t=e;for(;e.$hasMore;)e=await e.$getNextPage(),t=[...e,...t];return t.$getNextPage=async()=>{throw new Error("No more pages in this request")},t.$getAll=async()=>t,t.$hasMore=!1,t.$rawResponse=u,t},l}async query(e,t={},n={}){const r=s.defaults(t,n,this.defaultQueryOptions),i=h._prepareUrl(this.options.server,e,!1,r);let o={};this.apiKey&&(o.zsessionid=this.apiKey);const a=await this.throttle.queueAction(async()=>{const e=await c(i,{method:"GET",mode:"cors",headers:o,credentials:"include"});return await h.manageResponse(e)},this.options.maxReadRetrys);return a.$params=r,a.$hasMore=a.$rawResponse.TotalResultCount>=r.start+r.pagesize,a.$getNextPage=async()=>{if(a.$hasMore){let r=s.cloneDeep(t);return r.start+=t.pagesize,this.query(e,r,n)}throw new Error("No more pages in this request")},a.forEach(e=>this._decorateObject(e)),a}async save(e,t={},n={}){let r,i,o,a;if(o=s.isObject(e)?e:t,s.isString(e))r=e,o=t,a=n;else{if(!s.isObject(o)||!s.isString(o._ref))throw new Error('Input must be either a string representing a type like "Defect" or an object containing a string field "_ref"');a=t,o=e}let l={};if(this.apiKey&&(l.zsessionid=this.apiKey),!o.Project&&this.options.project&&(o.Project=this.options.project),o._ref)i=h._prepareUrl(this.options.server,h.getTypeFromRef(o._ref),h.getIdFromRef(o._ref),a);else{const e=s.isNumber(o.ObjectID)?`${o.ObjectID}`:"create";i=h._prepareUrl(this.options.server,r,e,a),i=s.isNumber(o.ObjectID)?`${i}/${o.ObjectID}?`:`${i}/create?`}const u={};u[r]=o;const d=JSON.stringify(u),_=await this.throttle.queueAction(async()=>{const e=await c(i,{method:"PUT",mode:"cors",headers:l,credentials:"include",body:d});return await h.manageResponse(e)},this.options.maxWriteRetrys);return _.$params=a,this._decorateObject(_),_}async get(e,t=null,n={}){const r=await this._request(e,t,n,"GET");return this._decorateObject(r),r}async getCollection(e,t,n={}){const r=s.defaults(n,this.defaultQueryOptions),i=h.getRef(e),o=h.getTypeFromRef(i),a=`${h.getIdFromRef(i)}/${t}`,l=h._prepareUrl(this.options.server,o,a,r);let u={};this.apiKey&&(u.zsessionid=this.apiKey);const d=await this.throttle.queueAction(async()=>{const e=await c(l,{method:"GET",mode:"cors",headers:u,credentials:"include"});return await h.manageResponse(e)},this.options.maxReadRetrys);return d.$params=r,d.forEach(e=>this._decorateObject(e)),e[t]=s.cloneDeep(s.defaults(d,e[t])),d}async _request(e,t=null,n={},r){let i=e;o.Ref.isRef(e)&&(i=h.getTypeFromRef(e),t=h.getIdFromRef(e));const a=s.defaults(n,{fetch:!0},this.defaultQueryOptions);delete a.project,delete a.workspace;const l=h._prepareUrl(this.options.server,i,t,a),u={zsessionid:this.apiKey};let d="PUT"===r?this.options.maxWriteRetrys:this.options.maxReadRetrys,_=await this.throttle.queueAction(async()=>{const e=await c(l,{method:r,mode:"cors",headers:u,credentials:"include"});return await h.manageResponse(e)},d);return(_=_[s.keys(_)[0]]).$params=a,_}async _decorateObject(e){e.$save=()=>this.save(e),e.$delete=()=>this.delete(e)}async delete(e,t={},n=!1){let r=e;r=s.isObject(e)?r._ref:r;const i=await this._request(r,null,t,"DELETE");if(!n){await h.delay(500)}return i}static getRef(e,t=0){let n;if(s.isObject(e)){if(n=e,s.isString(n._ref))return n._ref;throw new Error("_ref must be specified to use getRef from a RallyObject")}return s.isNumber(t)&&t?`/${e}/${t}`:e.toString()}static getIdFromRef(e){return o.Ref.getId(e)}static getTypeFromRef(e){return o.Ref.getType(e)}get defaultQueryOptions(){return{fetch:["ObjectID","Name"],start:1,pagesize:2e3,projectScopeUp:!0,projectScopeDown:!0,compact:!1,includePermissions:!0,project:void 0,workspace:this.workspace}}static get defaultLookbackRequest(){return{find:{},fields:["ObjectID","Name"],hydrate:[],start:0,pagesize:100,removeUnauthorizedSnapshots:!0}}static _prepareUrl(e,t,n="",r={}){s.isNumber(n)&&(n=n.toString()),r.workspace||delete r.workspace,r.project||delete r.project;const i=new u(r);return e.endsWith("/")||(e+="/"),`${e}slm/webservice/v2.0/${t}${n=s.isString(n)?`/${n}`:""}?${i.toString()}`}static async delay(e,t=(()=>{})){return new Promise(n=>{setTimeout(n.bind(null,t),e)})}}t.Client=h},function(e,t){e.exports=fetch},function(e,t){e.exports=URLSearchParams},function(e,t,n){"use strict";e.exports=n(10)},function(e,t,n){"use strict";var r,s,i;r=n(11),s=n(1),i=class{constructor(e){this.Events=new s(this),this._length=0,this._lists=function(){var t,n,s;for(s=[],t=1,n=e;1<=n?t<=n:t>=n;1<=n?++t:--t)s.push(new r(()=>this.incr(),()=>this.decr()));return s}.call(this)}incr(){if(0==this._length++)return this.Events.trigger("leftzero")}decr(){if(0==--this._length)return this.Events.trigger("zero")}push(e){return this._lists[e.options.priority].push(e)}queued(e){return null!=e?this._lists[e].length:this._length}shiftAll(e){return this._lists.forEach(function(t){return t.forEachShift(e)})}getFirst(e=this._lists){var t,n,r;for(t=0,n=e.length;t<n;t++)if((r=e[t]).length>0)return r;return[]}shiftLastFrom(e){return this.getFirst(this._lists.slice(e).reverse()).shift()}},e.exports=i},function(e,t,n){"use strict";function r(e,t,n,r,s,i,o){try{var a=e[i](o),c=a.value}catch(e){return void n(e)}a.done?t(c):Promise.resolve(c).then(r,s)}function s(e){return function(){var t=this,n=arguments;return new Promise(function(s,i){var o=e.apply(t,n);function a(e){r(o,s,i,a,c,"next",e)}function c(e){r(o,s,i,a,c,"throw",e)}a(void 0)})}}var i,o,a;a=n(0),i=n(2),o=class{constructor(e,t,n,r,s,i,o,c){this.task=e,this.args=t,this.rejectOnDrop=s,this.Events=i,this._states=o,this.Promise=c,this.options=a.load(n,r),this.options.priority=this._sanitizePriority(this.options.priority),this.options.id===r.id&&(this.options.id=`${this.options.id}-${this._randomIndex()}`),this.promise=new this.Promise((e,t)=>{this._resolve=e,this._reject=t}),this.retryCount=0}_sanitizePriority(e){var t;return(t=~~e!==e?5:e)<0?0:t>9?9:t}_randomIndex(){return Math.random().toString(36).slice(2)}doDrop({error:e,message:t="This job has been dropped by Bottleneck"}={}){return!!this._states.remove(this.options.id)&&(this.rejectOnDrop&&this._reject(null!=e?e:new i(t)),this.Events.trigger("dropped",{args:this.args,options:this.options,task:this.task,promise:this.promise}),!0)}_assertStatus(e){var t;if((t=this._states.jobStatus(this.options.id))!==e&&("DONE"!==e||null!==t))throw new i(`Invalid job status ${t}, expected ${e}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`)}doReceive(){return this._states.start(this.options.id),this.Events.trigger("received",{args:this.args,options:this.options})}doQueue(e,t){return this._assertStatus("RECEIVED"),this._states.next(this.options.id),this.Events.trigger("queued",{args:this.args,options:this.options,reachedHWM:e,blocked:t})}doRun(){return 0===this.retryCount?(this._assertStatus("QUEUED"),this._states.next(this.options.id)):this._assertStatus("EXECUTING"),this.Events.trigger("scheduled",{args:this.args,options:this.options})}doExecute(e,t,n,r){var i=this;return s(function*(){var s,o,a;0===i.retryCount?(i._assertStatus("RUNNING"),i._states.next(i.options.id)):i._assertStatus("EXECUTING"),o={args:i.args,options:i.options,retryCount:i.retryCount},i.Events.trigger("executing",o);try{if(a=yield null!=e?e.schedule(i.options,i.task,...i.args):i.task(...i.args),t())return i.doDone(o),yield r(i.options,o),i._assertStatus("DONE"),i._resolve(a)}catch(e){return s=e,i._onFailure(s,o,t,n,r)}})()}doExpire(e,t,n){var r,s;return this._assertStatus("EXECUTING"),s={args:this.args,options:this.options,retryCount:this.retryCount},r=new i(`This job timed out after ${this.options.expiration} ms.`),this._onFailure(r,s,e,t,n)}_onFailure(e,t,n,r,i){var o=this;return s(function*(){var s,a;if(n())return null!=(s=yield o.Events.trigger("failed",e,t))?(a=~~s,o.Events.trigger("retry",`Retrying ${o.options.id} after ${a} ms`,t),o.retryCount++,r(a)):(o.doDone(t),yield i(o.options,t),o._assertStatus("DONE"),o._reject(e))})()}doDone(e){return this._assertStatus("EXECUTING"),this._states.next(this.options.id),this.Events.trigger("done",e)}},e.exports=o},function(e,t,n){"use strict";function r(e,t,n,r,s,i,o){try{var a=e[i](o),c=a.value}catch(e){return void n(e)}a.done?t(c):Promise.resolve(c).then(r,s)}function s(e){return function(){var t=this,n=arguments;return new Promise(function(s,i){var o=e.apply(t,n);function a(e){r(o,s,i,a,c,"next",e)}function c(e){r(o,s,i,a,c,"throw",e)}a(void 0)})}}var i,o,a;a=n(0),i=n(2),o=class{constructor(e,t,n){this.instance=e,this.storeOptions=t,this.clientId=this.instance._randomIndex(),a.load(n,n,this),this._nextRequest=this._lastReservoirRefresh=this._lastReservoirIncrease=Date.now(),this._running=0,this._done=0,this._unblockTime=0,this.ready=this.Promise.resolve(),this.clients={},this._startHeartbeat()}_startHeartbeat(){var e;return null==this.heartbeat&&(null!=this.storeOptions.reservoirRefreshInterval&&null!=this.storeOptions.reservoirRefreshAmount||null!=this.storeOptions.reservoirIncreaseInterval&&null!=this.storeOptions.reservoirIncreaseAmount)?"function"==typeof(e=this.heartbeat=setInterval(()=>{var e,t,n,r,s;if(r=Date.now(),null!=this.storeOptions.reservoirRefreshInterval&&r>=this._lastReservoirRefresh+this.storeOptions.reservoirRefreshInterval&&(this._lastReservoirRefresh=r,this.storeOptions.reservoir=this.storeOptions.reservoirRefreshAmount,this.instance._drainAll(this.computeCapacity())),null!=this.storeOptions.reservoirIncreaseInterval&&r>=this._lastReservoirIncrease+this.storeOptions.reservoirIncreaseInterval){var i=this.storeOptions;if(e=i.reservoirIncreaseAmount,n=i.reservoirIncreaseMaximum,s=i.reservoir,this._lastReservoirIncrease=r,(t=null!=n?Math.min(e,n-s):e)>0)return this.storeOptions.reservoir+=t,this.instance._drainAll(this.computeCapacity())}},this.heartbeatInterval)).unref?e.unref():void 0:clearInterval(this.heartbeat)}__publish__(e){var t=this;return s(function*(){return yield t.yieldLoop(),t.instance.Events.trigger("message",e.toString())})()}__disconnect__(e){var t=this;return s(function*(){return yield t.yieldLoop(),clearInterval(t.heartbeat),t.Promise.resolve()})()}yieldLoop(e=0){return new this.Promise(function(t,n){return setTimeout(t,e)})}computePenalty(){var e;return null!=(e=this.storeOptions.penalty)?e:15*this.storeOptions.minTime||5e3}__updateSettings__(e){var t=this;return s(function*(){return yield t.yieldLoop(),a.overwrite(e,e,t.storeOptions),t._startHeartbeat(),t.instance._drainAll(t.computeCapacity()),!0})()}__running__(){var e=this;return s(function*(){return yield e.yieldLoop(),e._running})()}__queued__(){var e=this;return s(function*(){return yield e.yieldLoop(),e.instance.queued()})()}__done__(){var e=this;return s(function*(){return yield e.yieldLoop(),e._done})()}__groupCheck__(e){var t=this;return s(function*(){return yield t.yieldLoop(),t._nextRequest+t.timeout<e})()}computeCapacity(){var e,t,n=this.storeOptions;return e=n.maxConcurrent,t=n.reservoir,null!=e&&null!=t?Math.min(e-this._running,t):null!=e?e-this._running:null!=t?t:null}conditionsCheck(e){var t;return null==(t=this.computeCapacity())||e<=t}__incrementReservoir__(e){var t=this;return s(function*(){var n;return yield t.yieldLoop(),n=t.storeOptions.reservoir+=e,t.instance._drainAll(t.computeCapacity()),n})()}__currentReservoir__(){var e=this;return s(function*(){return yield e.yieldLoop(),e.storeOptions.reservoir})()}isBlocked(e){return this._unblockTime>=e}check(e,t){return this.conditionsCheck(e)&&this._nextRequest-t<=0}__check__(e){var t=this;return s(function*(){var n;return yield t.yieldLoop(),n=Date.now(),t.check(e,n)})()}__register__(e,t,n){var r=this;return s(function*(){var e,n;return yield r.yieldLoop(),e=Date.now(),r.conditionsCheck(t)?(r._running+=t,null!=r.storeOptions.reservoir&&(r.storeOptions.reservoir-=t),n=Math.max(r._nextRequest-e,0),r._nextRequest=e+n+r.storeOptions.minTime,{success:!0,wait:n,reservoir:r.storeOptions.reservoir}):{success:!1}})()}strategyIsBlock(){return 3===this.storeOptions.strategy}__submit__(e,t){var n=this;return s(function*(){var r,s,o;if(yield n.yieldLoop(),null!=n.storeOptions.maxConcurrent&&t>n.storeOptions.maxConcurrent)throw new i(`Impossible to add a job having a weight of ${t} to a limiter having a maxConcurrent setting of ${n.storeOptions.maxConcurrent}`);return s=Date.now(),o=null!=n.storeOptions.highWater&&e===n.storeOptions.highWater&&!n.check(t,s),(r=n.strategyIsBlock()&&(o||n.isBlocked(s)))&&(n._unblockTime=s+n.computePenalty(),n._nextRequest=n._unblockTime+n.storeOptions.minTime,n.instance._dropAllQueued()),{reachedHWM:o,blocked:r,strategy:n.storeOptions.strategy}})()}__free__(e,t){var n=this;return s(function*(){return yield n.yieldLoop(),n._running-=t,n._done+=t,n.instance._drainAll(n.computeCapacity()),{running:n._running}})()}},e.exports=o},function(e,t,n){"use strict";function r(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=[],r=!0,s=!1,i=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){s=!0,i=e}finally{try{r||null==a.return||a.return()}finally{if(s)throw i}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function s(e,t,n,r,s,i,o){try{var a=e[i](o),c=a.value}catch(e){return void n(e)}a.done?t(c):Promise.resolve(c).then(r,s)}function i(e){return function(){var t=this,n=arguments;return new Promise(function(r,i){var o=e.apply(t,n);function a(e){s(o,r,i,a,c,"next",e)}function c(e){s(o,r,i,a,c,"throw",e)}a(void 0)})}}var o,a,c,l,u;u=n(0),o=n(2),c=n(4),a=n(6),l=class{constructor(e,t,n){this.instance=e,this.storeOptions=t,this.originalId=this.instance.id,this.clientId=this.instance._randomIndex(),u.load(n,n,this),this.clients={},this.capacityPriorityCounters={},this.sharedConnection=null!=this.connection,null==this.connection&&(this.connection="redis"===this.instance.datastore?new c({clientOptions:this.clientOptions,Promise:this.Promise,Events:this.instance.Events}):"ioredis"===this.instance.datastore?new a({clientOptions:this.clientOptions,clusterNodes:this.clusterNodes,Promise:this.Promise,Events:this.instance.Events}):void 0),this.instance.connection=this.connection,this.instance.datastore=this.connection.datastore,this.ready=this.connection.ready.then(e=>(this.clients=e,this.runScript("init",this.prepareInitSettings(this.clearDatastore)))).then(()=>this.connection.__addLimiter__(this.instance)).then(()=>this.runScript("register_client",[this.instance.queued()])).then(()=>{var e;return"function"==typeof(e=this.heartbeat=setInterval(()=>this.runScript("heartbeat",[]).catch(e=>this.instance.Events.trigger("error",e)),this.heartbeatInterval)).unref&&e.unref(),this.clients})}__publish__(e){var t=this;return i(function*(){return(yield t.ready).client.publish(t.instance.channel(),`message:${e.toString()}`)})()}onMessage(e,t){var n=this;return i(function*(){var e,s,o,a,c,l,u,h,d,_;try{u=t.indexOf(":");var p=[t.slice(0,u),t.slice(u+1)];if(o=p[1],"capacity"===(_=p[0]))return yield n.instance._drainAll(o.length>0?~~o:void 0);if("capacity-priority"===_){var v=r(o.split(":"),3);return d=v[0],h=v[1],s=v[2],e=d.length>0?~~d:void 0,h===n.clientId?(a=yield n.instance._drainAll(e),l=null!=e?e-(a||0):"",yield n.clients.client.publish(n.instance.channel(),`capacity-priority:${l}::${s}`)):""===h?(clearTimeout(n.capacityPriorityCounters[s]),delete n.capacityPriorityCounters[s],n.instance._drainAll(e)):n.capacityPriorityCounters[s]=setTimeout(i(function*(){var t;try{return delete n.capacityPriorityCounters[s],yield n.runScript("blacklist_client",[h]),yield n.instance._drainAll(e)}catch(e){return t=e,n.instance.Events.trigger("error",t)}}),1e3)}if("message"===_)return n.instance.Events.trigger("message",o);if("blocked"===_)return yield n.instance._dropAllQueued()}catch(e){return c=e,n.instance.Events.trigger("error",c)}})()}__disconnect__(e){return clearInterval(this.heartbeat),this.sharedConnection?this.connection.__removeLimiter__(this.instance):this.connection.disconnect(e)}runScript(e,t){var n=this;return i(function*(){return"init"!==e&&"register_client"!==e&&(yield n.ready),new n.Promise((r,s)=>{var i,o;return i=[Date.now(),n.clientId].concat(t),n.instance.Events.trigger("debug",`Calling Redis script: ${e}.lua`,i),o=n.connection.__scriptArgs__(e,n.originalId,i,function(e,t){return null!=e?s(e):r(t)}),n.connection.__scriptFn__(e)(...o)}).catch(r=>"SETTINGS_KEY_NOT_FOUND"===r.message?"heartbeat"===e?n.Promise.resolve():n.runScript("init",n.prepareInitSettings(!1)).then(()=>n.runScript(e,t)):"UNKNOWN_CLIENT"===r.message?n.runScript("register_client",[n.instance.queued()]).then(()=>n.runScript(e,t)):n.Promise.reject(r))})()}prepareArray(e){var t,n,r,s;for(r=[],t=0,n=e.length;t<n;t++)s=e[t],r.push(null!=s?s.toString():"");return r}prepareObject(e){var t,n,r;for(n in t=[],e)r=e[n],t.push(n,null!=r?r.toString():"");return t}prepareInitSettings(e){var t;return(t=this.prepareObject(Object.assign({},this.storeOptions,{id:this.originalId,version:this.instance.version,groupTimeout:this.timeout,clientTimeout:this.clientTimeout}))).unshift(e?1:0,this.instance.version),t}convertBool(e){return!!e}__updateSettings__(e){var t=this;return i(function*(){return yield t.runScript("update_settings",t.prepareObject(e)),u.overwrite(e,e,t.storeOptions)})()}__running__(){return this.runScript("running",[])}__queued__(){return this.runScript("queued",[])}__done__(){return this.runScript("done",[])}__groupCheck__(){var e=this;return i(function*(){return e.convertBool(yield e.runScript("group_check",[]))})()}__incrementReservoir__(e){return this.runScript("increment_reservoir",[e])}__currentReservoir__(){return this.runScript("current_reservoir",[])}__check__(e){var t=this;return i(function*(){return t.convertBool(yield t.runScript("check",t.prepareArray([e])))})()}__register__(e,t,n){var s=this;return i(function*(){var i,o,a,c=r(yield s.runScript("register",s.prepareArray([e,t,n])),3);return o=c[0],a=c[1],i=c[2],{success:s.convertBool(o),wait:a,reservoir:i}})()}__submit__(e,t){var n=this;return i(function*(){var s,i,a,c,l;try{var u=r(yield n.runScript("submit",n.prepareArray([e,t])),3);return c=u[0],s=u[1],l=u[2],{reachedHWM:n.convertBool(c),blocked:n.convertBool(s),strategy:l}}catch(e){if(0===(i=e).message.indexOf("OVERWEIGHT")){var h=r(i.message.split(":"),3);throw h[0],t=h[1],a=h[2],new o(`Impossible to add a job having a weight of ${t} to a limiter having a maxConcurrent setting of ${a}`)}throw i}})()}__free__(e,t){var n=this;return i(function*(){return{running:yield n.runScript("free",n.prepareArray([e]))}})()}},e.exports=l},function(e){e.exports={"blacklist_client.lua":"local blacklist = ARGV[num_static_argv + 1]\n\nif redis.call('zscore', client_last_seen_key, blacklist) then\n  redis.call('zadd', client_last_seen_key, 0, blacklist)\nend\n\n\nreturn {}\n","check.lua":"local weight = tonumber(ARGV[num_static_argv + 1])\n\nlocal capacity = process_tick(now, false)['capacity']\nlocal nextRequest = tonumber(redis.call('hget', settings_key, 'nextRequest'))\n\nreturn conditions_check(capacity, weight) and nextRequest - now <= 0\n","conditions_check.lua":"local conditions_check = function (capacity, weight)\n  return capacity == nil or weight <= capacity\nend\n","current_reservoir.lua":"return process_tick(now, false)['reservoir']\n","done.lua":"process_tick(now, false)\n\nreturn tonumber(redis.call('hget', settings_key, 'done'))\n","free.lua":"local index = ARGV[num_static_argv + 1]\n\nredis.call('zadd', job_expirations_key, 0, index)\n\nreturn process_tick(now, false)['running']\n","get_time.lua":"redis.replicate_commands()\n\nlocal get_time = function ()\n  local time = redis.call('time')\n\n  return tonumber(time[1]..string.sub(time[2], 1, 3))\nend\n","group_check.lua":"return not (redis.call('exists', settings_key) == 1)\n","heartbeat.lua":"process_tick(now, true)\n","increment_reservoir.lua":"local incr = tonumber(ARGV[num_static_argv + 1])\n\nredis.call('hincrby', settings_key, 'reservoir', incr)\n\nlocal reservoir = process_tick(now, true)['reservoir']\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn reservoir\n","init.lua":"local clear = tonumber(ARGV[num_static_argv + 1])\nlocal limiter_version = ARGV[num_static_argv + 2]\nlocal num_local_argv = num_static_argv + 2\n\nif clear == 1 then\n  redis.call('del', unpack(KEYS))\nend\n\nif redis.call('exists', settings_key) == 0 then\n  -- Create\n  local args = {'hmset', settings_key}\n\n  for i = num_local_argv + 1, #ARGV do\n    table.insert(args, ARGV[i])\n  end\n\n  redis.call(unpack(args))\n  redis.call('hmset', settings_key,\n    'nextRequest', now,\n    'lastReservoirRefresh', now,\n    'lastReservoirIncrease', now,\n    'running', 0,\n    'done', 0,\n    'unblockTime', 0,\n    'capacityPriorityCounter', 0\n  )\n\nelse\n  -- Apply migrations\n  local settings = redis.call('hmget', settings_key,\n    'id',\n    'version'\n  )\n  local id = settings[1]\n  local current_version = settings[2]\n\n  if current_version ~= limiter_version then\n    local version_digits = {}\n    for k, v in string.gmatch(current_version, \"([^.]+)\") do\n      table.insert(version_digits, tonumber(k))\n    end\n\n    -- 2.10.0\n    if version_digits[2] < 10 then\n      redis.call('hsetnx', settings_key, 'reservoirRefreshInterval', '')\n      redis.call('hsetnx', settings_key, 'reservoirRefreshAmount', '')\n      redis.call('hsetnx', settings_key, 'lastReservoirRefresh', '')\n      redis.call('hsetnx', settings_key, 'done', 0)\n      redis.call('hset', settings_key, 'version', '2.10.0')\n    end\n\n    -- 2.11.1\n    if version_digits[2] < 11 or (version_digits[2] == 11 and version_digits[3] < 1) then\n      if redis.call('hstrlen', settings_key, 'lastReservoirRefresh') == 0 then\n        redis.call('hmset', settings_key,\n          'lastReservoirRefresh', now,\n          'version', '2.11.1'\n        )\n      end\n    end\n\n    -- 2.14.0\n    if version_digits[2] < 14 then\n      local old_running_key = 'b_'..id..'_running'\n      local old_executing_key = 'b_'..id..'_executing'\n\n      if redis.call('exists', old_running_key) == 1 then\n        redis.call('rename', old_running_key, job_weights_key)\n      end\n      if redis.call('exists', old_executing_key) == 1 then\n        redis.call('rename', old_executing_key, job_expirations_key)\n      end\n      redis.call('hset', settings_key, 'version', '2.14.0')\n    end\n\n    -- 2.15.2\n    if version_digits[2] < 15 or (version_digits[2] == 15 and version_digits[3] < 2) then\n      redis.call('hsetnx', settings_key, 'capacityPriorityCounter', 0)\n      redis.call('hset', settings_key, 'version', '2.15.2')\n    end\n\n    -- 2.17.0\n    if version_digits[2] < 17 then\n      redis.call('hsetnx', settings_key, 'clientTimeout', 10000)\n      redis.call('hset', settings_key, 'version', '2.17.0')\n    end\n\n    -- 2.18.0\n    if version_digits[2] < 18 then\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseInterval', '')\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseAmount', '')\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseMaximum', '')\n      redis.call('hsetnx', settings_key, 'lastReservoirIncrease', now)\n      redis.call('hset', settings_key, 'version', '2.18.0')\n    end\n\n  end\n\n  process_tick(now, false)\nend\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn {}\n","process_tick.lua":"local process_tick = function (now, always_publish)\n\n  local compute_capacity = function (maxConcurrent, running, reservoir)\n    if maxConcurrent ~= nil and reservoir ~= nil then\n      return math.min((maxConcurrent - running), reservoir)\n    elseif maxConcurrent ~= nil then\n      return maxConcurrent - running\n    elseif reservoir ~= nil then\n      return reservoir\n    else\n      return nil\n    end\n  end\n\n  local settings = redis.call('hmget', settings_key,\n    'id',\n    'maxConcurrent',\n    'running',\n    'reservoir',\n    'reservoirRefreshInterval',\n    'reservoirRefreshAmount',\n    'lastReservoirRefresh',\n    'reservoirIncreaseInterval',\n    'reservoirIncreaseAmount',\n    'reservoirIncreaseMaximum',\n    'lastReservoirIncrease',\n    'capacityPriorityCounter',\n    'clientTimeout'\n  )\n  local id = settings[1]\n  local maxConcurrent = tonumber(settings[2])\n  local running = tonumber(settings[3])\n  local reservoir = tonumber(settings[4])\n  local reservoirRefreshInterval = tonumber(settings[5])\n  local reservoirRefreshAmount = tonumber(settings[6])\n  local lastReservoirRefresh = tonumber(settings[7])\n  local reservoirIncreaseInterval = tonumber(settings[8])\n  local reservoirIncreaseAmount = tonumber(settings[9])\n  local reservoirIncreaseMaximum = tonumber(settings[10])\n  local lastReservoirIncrease = tonumber(settings[11])\n  local capacityPriorityCounter = tonumber(settings[12])\n  local clientTimeout = tonumber(settings[13])\n\n  local initial_capacity = compute_capacity(maxConcurrent, running, reservoir)\n\n  --\n  -- Process 'running' changes\n  --\n  local expired = redis.call('zrangebyscore', job_expirations_key, '-inf', '('..now)\n\n  if #expired > 0 then\n    redis.call('zremrangebyscore', job_expirations_key, '-inf', '('..now)\n\n    local flush_batch = function (batch, acc)\n      local weights = redis.call('hmget', job_weights_key, unpack(batch))\n                      redis.call('hdel',  job_weights_key, unpack(batch))\n      local clients = redis.call('hmget', job_clients_key, unpack(batch))\n                      redis.call('hdel',  job_clients_key, unpack(batch))\n\n      -- Calculate sum of removed weights\n      for i = 1, #weights do\n        acc['total'] = acc['total'] + (tonumber(weights[i]) or 0)\n      end\n\n      -- Calculate sum of removed weights by client\n      local client_weights = {}\n      for i = 1, #clients do\n        local removed = tonumber(weights[i]) or 0\n        if removed > 0 then\n          acc['client_weights'][clients[i]] = (acc['client_weights'][clients[i]] or 0) + removed\n        end\n      end\n    end\n\n    local acc = {\n      ['total'] = 0,\n      ['client_weights'] = {}\n    }\n    local batch_size = 1000\n\n    -- Compute changes to Zsets and apply changes to Hashes\n    for i = 1, #expired, batch_size do\n      local batch = {}\n      for j = i, math.min(i + batch_size - 1, #expired) do\n        table.insert(batch, expired[j])\n      end\n\n      flush_batch(batch, acc)\n    end\n\n    -- Apply changes to Zsets\n    if acc['total'] > 0 then\n      redis.call('hincrby', settings_key, 'done', acc['total'])\n      running = tonumber(redis.call('hincrby', settings_key, 'running', -acc['total']))\n    end\n\n    for client, weight in pairs(acc['client_weights']) do\n      redis.call('zincrby', client_running_key, -weight, client)\n    end\n  end\n\n  --\n  -- Process 'reservoir' changes\n  --\n  local reservoirRefreshActive = reservoirRefreshInterval ~= nil and reservoirRefreshAmount ~= nil\n  if reservoirRefreshActive and now >= lastReservoirRefresh + reservoirRefreshInterval then\n    reservoir = reservoirRefreshAmount\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'lastReservoirRefresh', now\n    )\n  end\n\n  local reservoirIncreaseActive = reservoirIncreaseInterval ~= nil and reservoirIncreaseAmount ~= nil\n  if reservoirIncreaseActive and now >= lastReservoirIncrease + reservoirIncreaseInterval then\n    local num_intervals = math.floor((now - lastReservoirIncrease) / reservoirIncreaseInterval)\n    local incr = reservoirIncreaseAmount * num_intervals\n    if reservoirIncreaseMaximum ~= nil then\n      incr = math.min(incr, reservoirIncreaseMaximum - (reservoir or 0))\n    end\n    if incr > 0 then\n      reservoir = (reservoir or 0) + incr\n    end\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'lastReservoirIncrease', lastReservoirIncrease + (num_intervals * reservoirIncreaseInterval)\n    )\n  end\n\n  --\n  -- Clear unresponsive clients\n  --\n  local unresponsive = redis.call('zrangebyscore', client_last_seen_key, '-inf', (now - clientTimeout))\n  local unresponsive_lookup = {}\n  local terminated_clients = {}\n  for i = 1, #unresponsive do\n    unresponsive_lookup[unresponsive[i]] = true\n    if tonumber(redis.call('zscore', client_running_key, unresponsive[i])) == 0 then\n      table.insert(terminated_clients, unresponsive[i])\n    end\n  end\n  if #terminated_clients > 0 then\n    redis.call('zrem', client_running_key,         unpack(terminated_clients))\n    redis.call('hdel', client_num_queued_key,      unpack(terminated_clients))\n    redis.call('zrem', client_last_registered_key, unpack(terminated_clients))\n    redis.call('zrem', client_last_seen_key,       unpack(terminated_clients))\n  end\n\n  --\n  -- Broadcast capacity changes\n  --\n  local final_capacity = compute_capacity(maxConcurrent, running, reservoir)\n\n  if always_publish or (initial_capacity ~= nil and final_capacity == nil) then\n    -- always_publish or was not unlimited, now unlimited\n    redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\n\n  elseif initial_capacity ~= nil and final_capacity ~= nil and final_capacity > initial_capacity then\n    -- capacity was increased\n    -- send the capacity message to the limiter having the lowest number of running jobs\n    -- the tiebreaker is the limiter having not registered a job in the longest time\n\n    local lowest_concurrency_value = nil\n    local lowest_concurrency_clients = {}\n    local lowest_concurrency_last_registered = {}\n    local client_concurrencies = redis.call('zrange', client_running_key, 0, -1, 'withscores')\n\n    for i = 1, #client_concurrencies, 2 do\n      local client = client_concurrencies[i]\n      local concurrency = tonumber(client_concurrencies[i+1])\n\n      if (\n        lowest_concurrency_value == nil or lowest_concurrency_value == concurrency\n      ) and (\n        not unresponsive_lookup[client]\n      ) and (\n        tonumber(redis.call('hget', client_num_queued_key, client)) > 0\n      ) then\n        lowest_concurrency_value = concurrency\n        table.insert(lowest_concurrency_clients, client)\n        local last_registered = tonumber(redis.call('zscore', client_last_registered_key, client))\n        table.insert(lowest_concurrency_last_registered, last_registered)\n      end\n    end\n\n    if #lowest_concurrency_clients > 0 then\n      local position = 1\n      local earliest = lowest_concurrency_last_registered[1]\n\n      for i,v in ipairs(lowest_concurrency_last_registered) do\n        if v < earliest then\n          position = i\n          earliest = v\n        end\n      end\n\n      local next_client = lowest_concurrency_clients[position]\n      redis.call('publish', 'b_'..id,\n        'capacity-priority:'..(final_capacity or '')..\n        ':'..next_client..\n        ':'..capacityPriorityCounter\n      )\n      redis.call('hincrby', settings_key, 'capacityPriorityCounter', '1')\n    else\n      redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\n    end\n  end\n\n  return {\n    ['capacity'] = final_capacity,\n    ['running'] = running,\n    ['reservoir'] = reservoir\n  }\nend\n","queued.lua":"local clientTimeout = tonumber(redis.call('hget', settings_key, 'clientTimeout'))\nlocal valid_clients = redis.call('zrangebyscore', client_last_seen_key, (now - clientTimeout), 'inf')\nlocal client_queued = redis.call('hmget', client_num_queued_key, unpack(valid_clients))\n\nlocal sum = 0\nfor i = 1, #client_queued do\n  sum = sum + tonumber(client_queued[i])\nend\n\nreturn sum\n","refresh_expiration.lua":"local refresh_expiration = function (now, nextRequest, groupTimeout)\n\n  if groupTimeout ~= nil then\n    local ttl = (nextRequest + groupTimeout) - now\n\n    for i = 1, #KEYS do\n      redis.call('pexpire', KEYS[i], ttl)\n    end\n  end\n\nend\n","refs.lua":"local settings_key = KEYS[1]\nlocal job_weights_key = KEYS[2]\nlocal job_expirations_key = KEYS[3]\nlocal job_clients_key = KEYS[4]\nlocal client_running_key = KEYS[5]\nlocal client_num_queued_key = KEYS[6]\nlocal client_last_registered_key = KEYS[7]\nlocal client_last_seen_key = KEYS[8]\n\nlocal now = tonumber(ARGV[1])\nlocal client = ARGV[2]\n\nlocal num_static_argv = 2\n","register.lua":"local index = ARGV[num_static_argv + 1]\nlocal weight = tonumber(ARGV[num_static_argv + 2])\nlocal expiration = tonumber(ARGV[num_static_argv + 3])\n\nlocal state = process_tick(now, false)\nlocal capacity = state['capacity']\nlocal reservoir = state['reservoir']\n\nlocal settings = redis.call('hmget', settings_key,\n  'nextRequest',\n  'minTime',\n  'groupTimeout'\n)\nlocal nextRequest = tonumber(settings[1])\nlocal minTime = tonumber(settings[2])\nlocal groupTimeout = tonumber(settings[3])\n\nif conditions_check(capacity, weight) then\n\n  redis.call('hincrby', settings_key, 'running', weight)\n  redis.call('hset', job_weights_key, index, weight)\n  if expiration ~= nil then\n    redis.call('zadd', job_expirations_key, now + expiration, index)\n  end\n  redis.call('hset', job_clients_key, index, client)\n  redis.call('zincrby', client_running_key, weight, client)\n  redis.call('hincrby', client_num_queued_key, client, -1)\n  redis.call('zadd', client_last_registered_key, now, client)\n\n  local wait = math.max(nextRequest - now, 0)\n  local newNextRequest = now + wait + minTime\n\n  if reservoir == nil then\n    redis.call('hset', settings_key,\n      'nextRequest', newNextRequest\n    )\n  else\n    reservoir = reservoir - weight\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'nextRequest', newNextRequest\n    )\n  end\n\n  refresh_expiration(now, newNextRequest, groupTimeout)\n\n  return {true, wait, reservoir}\n\nelse\n  return {false}\nend\n","register_client.lua":"local queued = tonumber(ARGV[num_static_argv + 1])\n\n-- Could have been re-registered concurrently\nif not redis.call('zscore', client_last_seen_key, client) then\n  redis.call('zadd', client_running_key, 0, client)\n  redis.call('hset', client_num_queued_key, client, queued)\n  redis.call('zadd', client_last_registered_key, 0, client)\nend\n\nredis.call('zadd', client_last_seen_key, now, client)\n\nreturn {}\n","running.lua":"return process_tick(now, false)['running']\n","submit.lua":"local queueLength = tonumber(ARGV[num_static_argv + 1])\nlocal weight = tonumber(ARGV[num_static_argv + 2])\n\nlocal capacity = process_tick(now, false)['capacity']\n\nlocal settings = redis.call('hmget', settings_key,\n  'id',\n  'maxConcurrent',\n  'highWater',\n  'nextRequest',\n  'strategy',\n  'unblockTime',\n  'penalty',\n  'minTime',\n  'groupTimeout'\n)\nlocal id = settings[1]\nlocal maxConcurrent = tonumber(settings[2])\nlocal highWater = tonumber(settings[3])\nlocal nextRequest = tonumber(settings[4])\nlocal strategy = tonumber(settings[5])\nlocal unblockTime = tonumber(settings[6])\nlocal penalty = tonumber(settings[7])\nlocal minTime = tonumber(settings[8])\nlocal groupTimeout = tonumber(settings[9])\n\nif maxConcurrent ~= nil and weight > maxConcurrent then\n  return redis.error_reply('OVERWEIGHT:'..weight..':'..maxConcurrent)\nend\n\nlocal reachedHWM = (highWater ~= nil and queueLength == highWater\n  and not (\n    conditions_check(capacity, weight)\n    and nextRequest - now <= 0\n  )\n)\n\nlocal blocked = strategy == 3 and (reachedHWM or unblockTime >= now)\n\nif blocked then\n  local computedPenalty = penalty\n  if computedPenalty == nil then\n    if minTime == 0 then\n      computedPenalty = 5000\n    else\n      computedPenalty = 15 * minTime\n    end\n  end\n\n  local newNextRequest = now + computedPenalty + minTime\n\n  redis.call('hmset', settings_key,\n    'unblockTime', now + computedPenalty,\n    'nextRequest', newNextRequest\n  )\n\n  local clients_queued_reset = redis.call('hkeys', client_num_queued_key)\n  local queued_reset = {}\n  for i = 1, #clients_queued_reset do\n    table.insert(queued_reset, clients_queued_reset[i])\n    table.insert(queued_reset, 0)\n  end\n  redis.call('hmset', client_num_queued_key, unpack(queued_reset))\n\n  redis.call('publish', 'b_'..id, 'blocked:')\n\n  refresh_expiration(now, newNextRequest, groupTimeout)\nend\n\nif not blocked and not reachedHWM then\n  redis.call('hincrby', client_num_queued_key, client, 1)\nend\n\nreturn {reachedHWM, blocked, strategy}\n","update_settings.lua":"local args = {'hmset', settings_key}\n\nfor i = num_static_argv + 1, #ARGV do\n  table.insert(args, ARGV[i])\nend\n\nredis.call(unpack(args))\n\nprocess_tick(now, true)\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn {}\n","validate_client.lua":"if not redis.call('zscore', client_last_seen_key, client) then\n  return redis.error_reply('UNKNOWN_CLIENT')\nend\n\nredis.call('zadd', client_last_seen_key, now, client)\n","validate_keys.lua":"if not (redis.call('exists', settings_key) == 1) then\n  return redis.error_reply('SETTINGS_KEY_NOT_FOUND')\nend\n"}},function(e,t,n){"use strict";var r,s;r=n(2),s=class{constructor(e){this.status=e,this._jobs={},this.counts=this.status.map(function(){return 0})}next(e){var t,n;return n=(t=this._jobs[e])+1,null!=t&&n<this.status.length?(this.counts[t]--,this.counts[n]++,this._jobs[e]++):null!=t?(this.counts[t]--,delete this._jobs[e]):void 0}start(e){return 0,this._jobs[e]=0,this.counts[0]++}remove(e){var t;return null!=(t=this._jobs[e])&&(this.counts[t]--,delete this._jobs[e]),null!=t}jobStatus(e){var t;return null!=(t=this.status[this._jobs[e]])?t:null}statusJobs(e){var t,n,s,i;if(null!=e){if((n=this.status.indexOf(e))<0)throw new r(`status must be one of ${this.status.join(", ")}`);for(t in i=[],s=this._jobs)s[t]===n&&i.push(t);return i}return Object.keys(this._jobs)}statusCounts(){return this.counts.reduce((e,t,n)=>(e[this.status[n]]=t,e),{})}},e.exports=s},function(e,t,n){"use strict";function r(e,t,n,r,s,i,o){try{var a=e[i](o),c=a.value}catch(e){return void n(e)}a.done?t(c):Promise.resolve(c).then(r,s)}function s(e){return function(){var t=this,n=arguments;return new Promise(function(s,i){var o=e.apply(t,n);function a(e){r(o,s,i,a,c,"next",e)}function c(e){r(o,s,i,a,c,"throw",e)}a(void 0)})}}var i,o;i=n(11),o=class{constructor(e,t){this.schedule=this.schedule.bind(this),this.name=e,this.Promise=t,this._running=0,this._queue=new i}isEmpty(){return 0===this._queue.length}_tryToRun(){var e=this;return s(function*(){var t,n,r,i,o,a,c;if(e._running<1&&e._queue.length>0){e._running++;var l=e._queue.shift();return c=l.task,t=l.args,o=l.resolve,i=l.reject,n=yield s(function*(){try{return a=yield c(...t),function(){return o(a)}}catch(e){return r=e,function(){return i(r)}}})(),e._running--,e._tryToRun(),n()}})()}schedule(e,...t){var n,r,s;return s=r=null,n=new this.Promise(function(e,t){return s=e,r=t}),this._queue.push({task:e,args:t,resolve:s,reject:r}),this._tryToRun(),n}},e.exports=o},function(e){e.exports={version:"2.19.1"}},function(e,t,n){"use strict";function r(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=[],r=!0,s=!1,i=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){s=!0,i=e}finally{try{r||null==a.return||a.return()}finally{if(s)throw i}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function s(e,t,n,r,s,i,o){try{var a=e[i](o),c=a.value}catch(e){return void n(e)}a.done?t(c):Promise.resolve(c).then(r,s)}function i(e){return function(){var t=this,n=arguments;return new Promise(function(r,i){var o=e.apply(t,n);function a(e){s(o,r,i,a,c,"next",e)}function c(e){s(o,r,i,a,c,"throw",e)}a(void 0)})}}var o,a,c,l,u,h;h=n(0),o=n(1),l=n(4),c=n(6),u=n(5),a=function(){class e{constructor(e={}){this.deleteKey=this.deleteKey.bind(this),this.limiterOptions=e,h.load(this.limiterOptions,this.defaults,this),this.Events=new o(this),this.instances={},this.Bottleneck=n(10),this._startAutoCleanup(),this.sharedConnection=null!=this.connection,null==this.connection&&("redis"===this.limiterOptions.datastore?this.connection=new l(Object.assign({},this.limiterOptions,{Events:this.Events})):"ioredis"===this.limiterOptions.datastore&&(this.connection=new c(Object.assign({},this.limiterOptions,{Events:this.Events}))))}key(e=""){var t;return null!=(t=this.instances[e])?t:(()=>{var t;return t=this.instances[e]=new this.Bottleneck(Object.assign(this.limiterOptions,{id:`${this.id}-${e}`,timeout:this.timeout,connection:this.connection})),this.Events.trigger("created",t,e),t})()}deleteKey(e=""){var t=this;return i(function*(){var n,r;return r=t.instances[e],t.connection&&(n=yield t.connection.__runCommand__(["del",...u.allKeys(`${t.id}-${e}`)])),null!=r&&(delete t.instances[e],yield r.disconnect()),null!=r||n>0})()}limiters(){var e,t,n,r;for(e in n=[],t=this.instances)r=t[e],n.push({key:e,limiter:r});return n}keys(){return Object.keys(this.instances)}clusterKeys(){var e=this;return i(function*(){var t,n,s,i,o,a,c,l;if(null==e.connection)return e.Promise.resolve(e.keys());for(a=[],t=null,l=`b_${e.id}-`.length,n="_settings".length;0!==t;){var u=r(yield e.connection.__runCommand__(["scan",null!=t?t:0,"match",`b_${e.id}-*_settings`,"count",1e4]),2);for(t=~~u[0],i=0,c=(s=u[1]).length;i<c;i++)o=s[i],a.push(o.slice(l,-n))}return a})()}_startAutoCleanup(){var e,t=this;return clearInterval(this.interval),"function"==typeof(e=this.interval=setInterval(i(function*(){var e,n,r,s,i,o;for(n in i=Date.now(),s=[],r=t.instances){o=r[n];try{(yield o._store.__groupCheck__(i))?s.push(t.deleteKey(n)):s.push(void 0)}catch(t){e=t,s.push(o.Events.trigger("error",e))}}return s}),this.timeout/2)).unref?e.unref():void 0}updateSettings(e={}){if(h.overwrite(e,this.defaults,this),h.overwrite(e,e,this.limiterOptions),null!=e.timeout)return this._startAutoCleanup()}disconnect(e=!0){var t;if(!this.sharedConnection)return null!=(t=this.connection)?t.disconnect(e):void 0}}return e.prototype.defaults={timeout:3e5,connection:null,Promise:Promise,id:"group-key"},e}.call(void 0),e.exports=a},function(e,t,n){"use strict";var r,s,i;i=n(0),s=n(1),r=function(){class e{constructor(e={}){this.options=e,i.load(this.options,this.defaults,this),this.Events=new s(this),this._arr=[],this._resetPromise(),this._lastFlush=Date.now()}_resetPromise(){return this._promise=new this.Promise((e,t)=>this._resolve=e)}_flush(){return clearTimeout(this._timeout),this._lastFlush=Date.now(),this._resolve(),this.Events.trigger("batch",this._arr),this._arr=[],this._resetPromise()}add(e){var t;return this._arr.push(e),t=this._promise,this._arr.length===this.maxSize?this._flush():null!=this.maxTime&&1===this._arr.length&&(this._timeout=setTimeout(()=>this._flush(),this.maxTime)),t}}return e.prototype.defaults={maxTime:null,maxSize:null,Promise:Promise},e}.call(void 0),e.exports=r},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(7),s=n(3);!function(e){class t{constructor(e,...t){this.typeName=e,s.isObject(t[0])?this.client=t[0]:this.client=new r.Client(t[0],t[1])}async query(e,t={},n={}){return this.client.query(this.typeName,t,n)}async save(e,t={}){return this.client.save(e,t)}async get(e,t=0,n={}){return this.client.get(e,t,n)}async getCollection(e,t,n={}){return this.client.getCollection(e,t,n)}async delete(e,t={},n=!1){return this.client.delete(e,t,n)}}e.ClassClientBase=t;e.AllowedAttributeValue=class extends t{constructor(...e){super("AllowedAttributeValue",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.AllowedQueryOperator=class extends t{constructor(...e){super("AllowedQueryOperator",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.App=class extends t{constructor(...e){super("App",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Artifact=class extends t{constructor(...e){super("Artifact",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.ArtifactNotification=class extends t{constructor(...e){super("ArtifactNotification",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Attachment=class extends t{constructor(...e){super("Attachment",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.AttachmentContent=class extends t{constructor(...e){super("AttachmentContent",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.AttributeDefinition=class extends t{constructor(...e){super("AttributeDefinition",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Blocker=class extends t{constructor(...e){super("Blocker",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Build=class extends t{constructor(...e){super("Build",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.BuildDefinition=class extends t{constructor(...e){super("BuildDefinition",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Change=class extends t{constructor(...e){super("Change",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Changeset=class extends t{constructor(...e){super("Changeset",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Connection=class extends t{constructor(...e){super("Connection",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.ConversationPost=class extends t{constructor(...e){super("ConversationPost",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.CumulativeFlowData=class extends t{constructor(...e){super("CumulativeFlowData",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Dashboard=class extends t{constructor(...e){super("Dashboard",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.DataMoveRequest=class extends t{constructor(...e){super("DataMoveRequest",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Defect=class extends t{constructor(...e){super("Defect",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.DefectSuite=class extends t{constructor(...e){super("DefectSuite",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.DomainObject=class extends t{constructor(...e){super("DomainObject",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Feature=class extends t{constructor(...e){super("Feature",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.FeatureToggleEntity=class extends t{constructor(...e){super("FeatureToggleEntity",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.FlowState=class extends t{constructor(...e){super("FlowState",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.HierarchicalRequirement=class extends t{constructor(...e){super("HierarchicalRequirement",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.HierarchicalRequirementPredecessorRelationship=class extends t{constructor(...e){super("HierarchicalRequirementPredecessorRelationship",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Initiative=class extends t{constructor(...e){super("Initiative",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Investment=class extends t{constructor(...e){super("Investment",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Iteration=class extends t{constructor(...e){super("Iteration",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.IterationCumulativeFlowData=class extends t{constructor(...e){super("IterationCumulativeFlowData",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Milestone=class extends t{constructor(...e){super("Milestone",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.PPMConnection=class extends t{constructor(...e){super("PPMConnection",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Panel=class extends t{constructor(...e){super("Panel",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.PanelDefinitionConfigProperty=class extends t{constructor(...e){super("PanelDefinitionConfigProperty",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.PersistableObject=class extends t{constructor(...e){super("PersistableObject",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.PortfolioItem=class extends t{constructor(...e){super("PortfolioItem",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.PortfolioItemPredecessorRelationship=class extends t{constructor(...e){super("PortfolioItemPredecessorRelationship",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Preference=class extends t{constructor(...e){super("Preference",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.PreliminaryEstimate=class extends t{constructor(...e){super("PreliminaryEstimate",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.ProfileImage=class extends t{constructor(...e){super("ProfileImage",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Project=class extends t{constructor(...e){super("Project",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.ProjectPermission=class extends t{constructor(...e){super("ProjectPermission",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.PullRequest=class extends t{constructor(...e){super("PullRequest",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.RankableArtifact=class extends t{constructor(...e){super("RankableArtifact",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.RecycleBinEntry=class extends t{constructor(...e){super("RecycleBinEntry",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Release=class extends t{constructor(...e){super("Release",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.ReleaseCumulativeFlowData=class extends t{constructor(...e){super("ReleaseCumulativeFlowData",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Requirement=class extends t{constructor(...e){super("Requirement",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Revision=class extends t{constructor(...e){super("Revision",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.RevisionHistory=class extends t{constructor(...e){super("RevisionHistory",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Risk=class extends t{constructor(...e){super("Risk",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.SCMRepository=class extends t{constructor(...e){super("SCMRepository",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.SchedulableArtifact=class extends t{constructor(...e){super("SchedulableArtifact",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.ScheduledTestCase=class extends t{constructor(...e){super("ScheduledTestCase",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Scope=class extends t{constructor(...e){super("Scope",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.ScopedAttributeDefinition=class extends t{constructor(...e){super("ScopedAttributeDefinition",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Slice=class extends t{constructor(...e){super("Slice",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.State=class extends t{constructor(...e){super("State",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Subscription=class extends t{constructor(...e){super("Subscription",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.SubscriptionTag=class extends t{constructor(...e){super("SubscriptionTag",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Tag=class extends t{constructor(...e){super("Tag",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Task=class extends t{constructor(...e){super("Task",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.TestCase=class extends t{constructor(...e){super("TestCase",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.TestCaseResult=class extends t{constructor(...e){super("TestCaseResult",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.TestCaseStep=class extends t{constructor(...e){super("TestCaseStep",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.TestFolder=class extends t{constructor(...e){super("TestFolder",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.TestFolderStatus=class extends t{constructor(...e){super("TestFolderStatus",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.TestSet=class extends t{constructor(...e){super("TestSet",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.TimeEntryItem=class extends t{constructor(...e){super("TimeEntryItem",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.TimeEntryValue=class extends t{constructor(...e){super("TimeEntryValue",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.TypeDefinition=class extends t{constructor(...e){super("TypeDefinition",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.User=class extends t{constructor(...e){super("User",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.UserIterationCapacity=class extends t{constructor(...e){super("UserIterationCapacity",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.UserPermission=class extends t{constructor(...e){super("UserPermission",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.UserProfile=class extends t{constructor(...e){super("UserProfile",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.WebLinkDefinition=class extends t{constructor(...e){super("WebLinkDefinition",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.WebTab=class extends t{constructor(...e){super("WebTab",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.Workspace=class extends t{constructor(...e){super("Workspace",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.WorkspaceConfiguration=class extends t{constructor(...e){super("WorkspaceConfiguration",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.WorkspaceDomainObject=class extends t{constructor(...e){super("WorkspaceDomainObject",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}};e.WorkspacePermission=class extends t{constructor(...e){super("WorkspacePermission",s.isObject(e[0])?e[0]:new r.Client(e[0],e[1]))}}}(t.ClassClients||(t.ClassClients={}))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(3);t.Common=class{constructor(e){this.client=e}async getAllChildProjects(e,t=["Name","Workspace"],n=(e=>[])){const s=r.uniq(["Children",...t]);if(!e.length)return[];const i=e.filter(e=>!e.Children||!!e.Children.Count);let o=[],a=async()=>{if(!i.length)return;const e=i.pop();let t=[];try{t=await this.client.getCollection(e,"Children",{fetch:s})}catch(t){i.unshift(e)}finally{if(o=r.flatten([...o,...t]),n(o),i.length)return a()}};await Promise.all([a(),a(),a(),a(),a(),a(),a()]);const c=await this.getAllChildProjects(o,t,n);let l=r.flatten([...c,...e,...o]);const u={};return l.forEach(e=>{u[e._ref]=e}),l=Object.values(u)}}}]);
//# sourceMappingURL=web.js.map
Ext.override(Rally.ui.gridboard.SharedViewComboBox, {
    /**
     * This override fixes a bug in the SharedViewComboBox which prevents a newly created
     * view from appearing in the view picker until after an app reload
     */
    _isViewPreference: function(record) {
        return record.self.typePath === 'preference' &&
            record.get('Type') === 'View' &&
            // This is fix. Must use '==' not '===' for this to return true
            record.get('AppId') == this.getContext().getAppId();
    },

    /**
     * This override allows the `enableUrlSharing` option to work.
     * Must override `window.location` with `parent.location`.
     */
    getSharedViewParam: function() {
        var hash = parent.location.hash,
            matches = hash.match(/sharedViewId=(\d+)/);

        return matches && matches[1];
    },

    /**
     * Override to avoid a race condition when restoring columns when using
     * `enableUrlSharing`
     * _ensureLatestView is called out of the constructor after initComponent before store.load(), but store.load() is called immediately after
     * by the parent combobox. The asynchronous store.model.load() here will race with store.load() invoked by the parent. If
     * the store.load returns first, this function would miss the load event and never apply the latest view columns.
     * 
     * Ensure we don't miss the store.load() event by registering an event handler now (before the parent calls store.load()) and
     * that handler can act on the store.model.load() promise when it resolves. This allows both loads to proceed in parallel without
     * possibly missing the load event.
     */
    _ensureLatestView: function(state) {
        if (state.objectId && state.versionId) {
            var modelLoadDeferred = Ext.create('Deft.Deferred');
            this.store.model.load(state.objectId, {
                fetch: ['VersionId', 'Value'],
                success: function(record) {
                    modelLoadDeferred.resolve(record);
                }
            });
            this.store.on('load', function() {
                modelLoadDeferred.promise.then({
                    success: function(record) {
                        if (record && record.get('VersionId') !== state.versionId) {
                            this._applyView(this._decodeValue(record));
                        }
                    },
                    scope: this
                })
            }, this, { single: true });
        }
    },
})

Ext.define('Utils.AncestorPiAppFilter', {
    alias: 'plugin.UtilsAncestorPiAppFilter',
    mixins: [
        'Ext.AbstractPlugin',
        'Rally.Messageable'
    ],
    extend: 'Ext.Component',

    statics: {
        RENDER_AREA_ID: 'utils-ancestor-pi-app-filter',
        PANEL_RENDER_AREA_ID: 'multi-level-pi-app-filter-panel'
    },

    config: {
        /**
         * @cfg {Boolean}
         * The id of the component where the plugin will render its controls
         */
        renderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the filter button will render itself
         */
        btnRenderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the tabbed filter panel will render itself
         */
        panelRenderAreaId: 'multi-level-pi-app-filter-panel',

        /**
         * @cfg {Boolean}
         * Set to false to prevent app from displaying a multi-level PI filter
         */
        displayMultiLevelFilter: true,

        /**
         * @cfg {Boolean}
         * Set to true to indicate that this component is a publisher of events
         * to other apps using this plugin
         */
        publisher: false,

        /**
         * @cfg {Boolean}
         * Set to false to prevent the '-- None --' selection option if your app can't support
         * querying by a null ancestor (e.g. Lookback _ItemHierarchy)
         */
        allowNoEntry: true,

        /**
         * @cfg {Object}
         * Config applied to the app settings components
         */
        settingsConfig: {},

        /**
         * @cfg {Object}
         * Fetch list for PI Selector
         */
        defaultFetch: true,

        /**
         * @cfg {Array}
         * Whitelist array for inline filters
         */
        whiteListFields: [],

        /**
         * @cfg {Array}
         * Blacklist array for inline filters
         */
        blackListFields: [],

        /**
         * @cfg {Boolean}
         * Setting for inlineFilterButtonConfig
         */
        filterChildren: false,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker
         */
        ancestorLabel: 'With ancestor',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ancestorLabelWidth: 110,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown with the ancestor filter
         */
        ownerLabel: 'and owned by',

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown by itself
         */
        ownerOnlyLabel: 'Owned by',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ownerLabelWidth: 110,


        /**
         * @cfg {Number}
         * Style of the Portfolio Item Type picker label
         */
        labelStyle: 'font-size: medium',

        /**
         * @cfg {Number}
         * Minimum width for single row layout
         */
        singleRowMinWidth: 840,

        /**
         * @cfg {Array}
         * Field list for multi-level filter panel
         */
        defaultFilterFields: ['ArtifactSearch', 'Owner'],

        /**
         * @cfg {Boolean}
         * Set to true to hide filters on load
         */
        filtersHidden: false,

        /**
         * @cfg {Boolean}
         * Set to true to hide advanced filters on load
         */
        advancedFilterCollapsed: false
    },
    filterControls: [],
    portfolioItemTypes: [],
    readyDeferred: null,
    piTypesDeferred: null,
    isSubscriber: false,
    changeSubscribers: [],
    publishedValue: {},

    constructor: function () {
        this.callParent(arguments);
        this._setupPubSub();
        Ext.tip.QuickTipManager.init();
    },

    initComponent: function () {
        this.callParent(arguments);
        this.addEvents('ready', 'select', 'change');
    },

    init: function (cmp) {
        this.cmp = cmp;

        this.cmp.on('resize', this._onCmpResize, this);

        // Get the area where plugin controls will render
        this.renderArea = this.cmp.down('#' + this.renderAreaId);

        // Get the area where filter button will render
        this.btnRenderArea = this.cmp.down('#' + this.btnRenderAreaId);

        // Get the area where tabbed filter panel will render
        this.panelRenderArea = this.cmp.down('#' + this.panelRenderAreaId);

        // Extend app settings fields
        var cmpGetSettingsFields = this.cmp.getSettingsFields;
        this.cmp.getSettingsFields = function () {
            return this._getSettingsFields(cmpGetSettingsFields.apply(cmp, arguments));
        }.bind(this);

        // Extend app default settings fields
        var appDefaults = this.cmp.defaultSettings;
        appDefaults['Utils.AncestorPiAppFilter.enableAncestorPiFilter2'] = false;
        appDefaults['Utils.AncestorPiAppFilter.projectScope'] = 'current';
        appDefaults['Utils.AncestorPiAppFilter.enableMultiLevelPiFilter'] = false;
        this.cmp.setDefaultSettings(appDefaults);

        Ext.override(Rally.ui.inlinefilter.InlineFilterPanel, {
            // We don't want chevrons in the tab panel
            _alignChevron: function () {
                if (this.chevron) { this.chevron.hide(); }
            }
        });

        // Add the control components then fire ready
        Promise.all([this._addAncestorControls(), this._addFilters()]).then(
            function () {
                this._setReady();
            }.bind(this),
            function (error) {
                Rally.ui.notify.Notifier.showError({ message: error });
                this._setReady();
            }
        );
    },

    notifySubscribers: function (changeType) {
        var data = this._getValue();
        data.changeType = changeType;
        _.each(this.changeSubscribers, function (subscriberName) {
            this.publish(subscriberName, data);
        }, this);
    },

    // Returns a filter that will ensure results are children of the
    // selected ancestor portfolio item. type is the TypeDefinition 
    // for the Portfolio Item level you wish to fetch.
    getAncestorFilterForType: function (type) {
        var filter;
        var modelName = type.toLowerCase();
        var currentValues = this._getValue();

        if (currentValues.piTypePath) {
            var selectedPiTypePath = currentValues.piTypePath;
            var selectedRecord = currentValues.isPiSelected;
            var selectedPi = currentValues.pi;
            var pisAbove = this._piTypeAncestors(modelName, selectedPiTypePath);
            if (selectedRecord && selectedPi !== null && pisAbove !== null) {
                var property = this._propertyPrefix(modelName, pisAbove);
                if (property) {
                    filter = new Rally.data.wsapi.Filter({
                        property: property,
                        value: selectedPi
                    });
                }
            }
            else if (selectedPi !== null) {
                // Filter out any items of this type because the ancestor pi filter is
                // enabled, but this type doesn't have any pi ancestor types
                filter = new Rally.data.wsapi.Filter({
                    property: 'ObjectID',
                    value: 0
                });
            }
        }

        return filter;
    },

    // Returns an array containing all of the filters applied in the
    // multi-level filter as well as the selected ancestor PI if one
    // is selected. type is the TypeDefinition for the Portfolio Item
    // level you wish to fetch.
    getAllFiltersForType: function (type) {
        let ancestorFilter = this.getAncestorFilterForType(type);
        let filters = ancestorFilter ? [ancestorFilter] : [];
        filters = filters.concat(this.getMultiLevelFiltersForType(type));

        return filters;
    },

    // Returns an array containing all of the filters applied in the
    // multi-level filter. type is the TypeDefinition for the Portfolio 
    // Item level you wish to fetch.
    getMultiLevelFiltersForType: function (type) {
        let filters = [];
        let modelName = type.toLowerCase();
        let multiLevelFilters = this.getMultiLevelFilters();

        _.each(multiLevelFilters, function (val, key) {
            if (modelName === key.toLowerCase()) {
                filters = filters.concat(val);
            }
            else {
                let pisAbove = this._piTypeAncestors(modelName, key);

                if (val.length && pisAbove !== null) {
                    let property = this._propertyPrefix(modelName, pisAbove);
                    if (property) {
                        _.each(val, function (filter) {
                            filters.push(new Rally.data.wsapi.Filter({
                                property: `${property}.${filter.property}`,
                                operator: filter.operator,
                                value: filter.value
                            }));
                        }.bind(this));
                    }
                }
            }
        }.bind(this));

        return filters;
    },

    // Returns an object containing all of the filters applied in the multi-level
    // filter. Keys are the type definition field and the resulting values are arrays
    // of filters
    getMultiLevelFilters: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filters;
        }

        var filters = {};
        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
            filters[typeName] = filterControl.inlineFilterButton.getFilters();
        });

        return filters;
    },

    getSelectedPiRecord: function () {
        return this._getValue().piRecord;
    },

    getIgnoreProjectScope: function () {
        return this._getValue().ignoreProjectScope;
    },

    // Returns an object of states for all of the inline filters
    // Used for getting and setting shared views
    getMultiLevelFilterStates: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filterStates;
        }

        var states = {};
        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
            states[typeName] = filterControl.inlineFilterButton.getState();
        });

        return states;
    },

    // Sets the states of the inline filters
    // Used when applying a shared view to the filters
    setMultiLevelFilterStates: function (states) {
        if (!this._isSubscriber()) {
            this.tabPanel.removeAll();
            for (let key in states) {
                if (states.hasOwnProperty(key)) {
                    for (let i = 0; i < this.filterControls.length; i++) {
                        let typeName = (this.filterControls[i].inlineFilterButton.modelNames) || 'unknown';
                        if (typeName === key) {
                            this.filterControls[i].inlineFilterButton.applyState(states[key]);
                        }
                    }
                }
            }
            setTimeout(function () { this.tabPanel.setActiveTab(0); }.bind(this), 1500);
        }
    },

    _setupPubSub: function () {
        if (this.publisher) {
            this.subscribe(this, 'registerChangeSubscriber', function (subscriberName) {
                // Register new unique subscribers
                if (!_.contains(this.changeSubscribers, subscriberName)) {
                    this.changeSubscribers.push(subscriberName);
                }
                this.publish(subscriberName, this._getValue());
            }, this);
            // Ask any existing subscribers to re-register
            this.publish('reRegisterChangeSubscriber');
        }
        else {
            this.subscriberEventName = Rally.getApp().getAppId() + this.$className;
            // Subscribe to a channel dedicated to this app
            this.subscribe(this, this.subscriberEventName, function (data) {
                if (this.intervalTimer) {
                    clearInterval(this.intervalTimer);
                    delete this.intervalTimer;
                }
                if (!this.isSubscriber) {
                    this.isSubscriber = true;
                    this._hideControlCmp();
                }
                this.publishedValue = data;

                // Default to an ancestor change event for backwards compatibility
                if (data.changeType === 'ancestor' || !data.changeType) {
                    this._onSelect();
                }
                else {
                    this._onChange();
                }
            }, this);
            // Attempt to register with a publisher (if one exists)
            this.publish('registerChangeSubscriber', this.subscriberEventName);
            this.intervalTimer = setInterval(function () {
                this.publish('registerChangeSubscriber', this.subscriberEventName);
            }.bind(this), 500);
            this.subscribe(this, 'reRegisterChangeSubscriber', function () {
                this.publish('registerChangeSubscriber', this.subscriberEventName);
            }, this);
        }
    },

    _getValue: function () {
        var result = {};
        if (this._isSubscriber()) {
            result = this.publishedValue || {};
        }
        else {
            if (this.piTypeSelector) {
                var selectedPiType = this.piTypeSelector.getRecord();
                if (selectedPiType && this.piSelector) {
                    var selectedPiTypePath = selectedPiType.get('TypePath');
                    var selectedRecord = this.piSelector.getRecord();
                    var selectedPi = this.piSelector.getValue();
                    _.merge(result, {
                        piTypePath: selectedPiTypePath,
                        isPiSelected: !!selectedRecord,
                        pi: selectedPi,
                        piRecord: selectedRecord
                    });
                }
            }
            result.ignoreProjectScope = this._ignoreProjectScope();
            result.filters = this.getMultiLevelFilters();
            result.filterStates = this.getMultiLevelFilterStates();
        }
        return result;
    },

    _setReady: function () {
        this.ready = true;
        this.fireEvent('ready', this);
    },

    // Ancestor filter dropdowns have been selected
    _onSelect: function () {
        if (this.ready) {
            this.fireEvent('select', this);
        }
    },

    // Multi-level filters have changed
    _onChange: function () {
        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    _getSettingsFields: function (fields) {
        var currentSettings = Rally.getApp().getSettings();
        if (!currentSettings.hasOwnProperty('Utils.AncestorPiAppFilter.projectScope')) {
            currentSettings['Utils.AncestorPiAppFilter.projectScope'] = 'user';
        }
        var pluginSettingsFields = [{
            xtype: 'rallycheckboxfield',
            id: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            name: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            fieldLabel: 'Filter artifacts by ancestor portfolio item',
        }, {
            xtype: 'rallyportfolioitemtypecombobox',
            id: 'Utils.AncestorPiAppFilter.defaultPiType',
            name: 'Utils.AncestorPiAppFilter.defaultPiType',
            fieldLabel: "Default Portfolio Item type",
            valueField: 'TypePath',
            allowNoEntry: false,
            defaultSelectionPosition: 'last',
            // Disable the preference enabled combo box plugin so that this control value is app specific
            plugins: []
        },
        {
            xtype: 'radiogroup',
            fieldLabel: 'Show artifacts from',
            columns: 1,
            vertical: true,
            allowBlank: false,
            items: [{
                boxLabel: "User's current project(s).",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'current',
                checked: 'current' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            }, {
                boxLabel: "All projects in workspace.",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'workspace',
                checked: 'workspace' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            }, {
                boxLabel: 'User selectable (either current project(s) or all projects in workspace).',
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'user',
                checked: 'user' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            },],
            listeners: {
                scope: this,
                change: function () {
                    return;
                }
            }
        },
        {
            xtype: 'rallycheckboxfield',
            id: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            name: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            fieldLabel: 'Enable multi-level portfolio item filter',
        }
        ];
        pluginSettingsFields = _.map(pluginSettingsFields, function (pluginSettingsField) {
            return _.merge(pluginSettingsField, this.settingsConfig);
        }, this);
        // apply any settings config to each field added by the plugin
        return pluginSettingsFields.concat(fields || []);
    },

    // Requires that app settings are available (e.g. from 'beforelaunch')
    _addAncestorControls: function () {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        var ownerLabelWidth = this.ownerLabelWidth;
        if (this.cmp.getWidth() < this.singleRowMinWidth) {
            controlsLayout = 'vbox';
            ownerLabelWidth = this.ancestorLabelWidth;
        }
        var scopeControlByItself = false;
        if (this._showAncestorFilter() === false && this._showIgnoreProjectScopeControl() === true) {
            scopeControlByItself = true;
        }
        var controls = {
            xtype: 'container',
            id: 'controlsArea',
            overflowX: 'auto',
            layout: {
                type: 'hbox',
                align: 'top'
            },
            items: [{
                xtype: 'container',
                id: 'pubSubIndicatorArea',
                width: 25,
                padding: '6 5 0 0',
                hidden: !this.publisher && !this._isSubscriber(),
                items: [{
                    xtype: 'component',
                    id: 'publisherIndicator',
                    html: '<span class="icon-bullhorn icon-large"></span>',
                    hidden: !this.publisher
                },
                {
                    xtype: 'component',
                    id: 'subscriberIndicator',
                    html: '<span class="icon-link icon-large"></span>',
                    hidden: !this._isSubscriber()
                },
                ]
            }, {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: [{
                    xtype: 'container',
                    id: 'ancestorFilterArea',
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'container',
                        id: 'piTypeArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle'
                        },
                    },
                    {
                        xtype: 'container',
                        id: 'piSelectorArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle',
                            padding: '0 0 0 5'
                        },
                    }
                    ]
                }, {
                    xtype: 'container',
                    id: 'scopeControlArea',
                    width: 250,
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'rallycombobox',
                        id: 'ignoreScopeControl',
                        stateful: true,
                        stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.ignoreProjectScopeControl'),
                        stateEvents: ['select'],
                        hidden: this._isSubscriber() || !this._showIgnoreProjectScopeControl(),
                        displayField: 'text',
                        valueField: 'value',
                        labelStyle: this.labelStyle,
                        labelWidth: ownerLabelWidth,
                        fieldLabel: scopeControlByItself ? this.ownerOnlyLabel : this.ownerLabel,
                        // Don't set initial value with this component or it will override the state
                        storeConfig: {
                            fields: ['text', 'value'],
                            data: [{
                                text: "Current Project(s)",
                                value: false
                            }, {
                                text: "Any Project",
                                value: true
                            }]
                        },
                        listeners: {
                            scope: this,
                            change: function () {
                                this._onSelect();
                            }
                        },
                    }]
                }]
            }]
        };

        if (this.renderArea) {
            // Without this, the components are clipped on narrow windows
            this.renderArea.setOverflowXY('auto', 'auto');
            this.renderArea.add(controls);
        }

        this._addTooltips();

        // Need to get pi types sorted by ordinal lowest to highest for the filter logic to work
        return new Promise(function (resolve) {
            Rally.data.util.PortfolioItemHelper.getPortfolioItemTypes().then({
                scope: this,
                success: function (data) {
                    this.portfolioItemTypes = data;

                    if (!this._isSubscriber() && this._showAncestorFilter()) {
                        // Now create the pi type selector
                        this._addPiTypeSelector().then(function () {
                            this._addPiSelector(this.piTypeSelector.getValue(), null).then(
                                function () {
                                    resolve();
                                }.bind(this)
                            );
                        }.bind(this));
                    }
                    else {
                        resolve();
                    }
                }
            });
        }.bind(this));
    },

    _addPiTypeSelector: function (initialValue) {
        return new Promise(function (resolve) {
            this.piTypeSelector = Ext.create('Rally.ui.combobox.PortfolioItemTypeComboBox', {
                xtype: 'rallyportfolioitemtypecombobox',
                id: 'Utils.AncestorPiAppFilter.piType',
                name: 'Utils.AncestorPiAppFilter.piType',
                width: 250,
                // Disable the preference enabled combo box plugin so that this control value is app specific
                plugins: [],
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piType'),
                stateEvents: ['select'],
                fieldLabel: this.ancestorLabel,
                labelWidth: this.ancestorLabelWidth,
                labelStyle: this.labelStyle,
                valueField: 'TypePath',
                value: initialValue || this._defaultPortfolioItemType(),
                allowNoEntry: false,
                defaultSelectionPosition: 'first',
                listeners: {
                    scope: this,
                    ready: function (combobox) {
                        // Unfortunately we cannot use the combobox store of PI types for our filter
                        // logic because it is sorted by ordinal from highest to lowest so that the
                        // picker options have a an order familiar to the user.

                        // Don't add the change listener until ready. This prevents us
                        // from adding and removing the pi selector multiple times during
                        // startup which causes a null ptr exception in that component
                        combobox.addListener({
                            scope: this,
                            change: this._onPiTypeChange
                        });
                        resolve();
                    }
                }
            });
            this.renderArea.down('#piTypeArea').add(this.piTypeSelector);
        }.bind(this));
    },

    _addTooltips: function () {
        Ext.tip.QuickTipManager.register({
            target: 'publisherIndicator',
            text: 'This app broadcasts filter settings to any enabled ancestor filtered apps (indicated with <span class="icon-link icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        Ext.tip.QuickTipManager.register({
            target: 'subscriberIndicator',
            text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        if (this._isSubscriber()) {
            Ext.tip.QuickTipManager.register({
                target: 'subscriberFilterIndicator',
                text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
                showDelay: 50,
                border: true
            });
        }
    },

    _onCmpResize: function (cmp, width) {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        if (width < this.singleRowMinWidth) {
            controlsLayout = {
                type: 'vbox'
            };
        }
        var filtersArea = this.renderArea.down('#filtersArea');
        if (filtersArea) {
            var controlsArea = this.renderArea.down('#controlsArea');
            var filters = filtersArea.removeAll(false);
            var newFiltersArea = {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: filters,
                hidden: filtersArea.isHidden()
            };
            controlsArea.remove(filtersArea, false);
            controlsArea.add(newFiltersArea);
        }
    },

    _hideControlCmp: function () {
        if (this.renderArea) {
            this.renderArea.down('#pubSubIndicatorArea').show();
            this.renderArea.down('#subscriberIndicator').show();
            this.renderArea.down('#filtersArea').hide();
        }
    },

    _onPiTypeChange: function (piTypeSelector, newValue) {
        if (newValue) {
            let currentPi = this._getValue().pi;
            this._removePiSelector();
            this._addPiSelector(newValue).then(
                function () {
                    this._setReady();
                    // If an ancestor was selected it has now been cleared, so fire select event
                    if (currentPi) {
                        this._onSelect();
                    }
                }.bind(this)
            );
        }
    },

    _removePiSelector: function () {
        this.renderArea.down('#piSelectorArea').removeAll(true);
    },

    _addPiSelector: function (piType, initialValue) {
        return new Promise(function (resolve) {
            this.piSelector = Ext.create('Rally.ui.combobox.ArtifactSearchComboBox', {
                id: 'Utils.AncestorPiAppFilter.piSelector',
                width: 250,
                labelAlign: 'top',
                storeConfig: {
                    models: piType,
                    autoLoad: true,
                    fetch: this.defaultFetch,
                    context: {
                        project: null
                    }
                },
                queryDelay: 7000,
                autoSelectCurrentItem: false,
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piSelector'),
                stateEvents: ['select'],
                valueField: '_ref',
                allowClear: true,
                clearValue: null,
                allowNoEntry: this.allowNoEntry,
                noEntryValue: '',
                value: initialValue || '',
                // forceSelection: false,
                defaultSelectionPosition: null,
                listeners: {
                    scope: this,
                    select: function () {
                        this._onSelect();
                    },
                    ready: function () {
                        resolve();
                    }
                }
            });
            // Allow this combobox to save null state (which is default behavior of
            // stateful mixin, but for some reason was overridden in combobox)
            Ext.override(this.piSelector, {
                saveState: function () {
                    var me = this,
                        id = me.stateful && me.getStateId(),
                        hasListeners = me.hasListeners,
                        state;

                    if (id) {
                        state = me.getState() || {}; //pass along for custom interactions
                        if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) {
                            Ext.state.Manager.set(id, state);
                            if (hasListeners.statesave) {
                                me.fireEvent('statesave', me, state);
                            }
                        }
                    }
                }
            });
            this.renderArea.down('#piSelectorArea').add(this.piSelector);
        }.bind(this));
    },

    _setPiSelector: function (piType, pi) {
        return new Promise(function (resolve) {
            this.piTypeSelector.suspendEvents(false);
            this.piTypeSelector.setValue(piType);
            this._removePiSelector();
            this._addPiSelector(piType, pi).then(function () {
                this.piSelector.setValue(pi);
                this.piTypeSelector.resumeEvents();
                resolve();
            }.bind(this));
        }.bind(this));
    },

    _showAncestorFilter: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.enableAncestorPiFilter2');
    },

    _showIgnoreProjectScopeControl: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'user';
    },

    _ignoreProjectScope: function () {
        var result = false;
        if (this._showIgnoreProjectScopeControl()) {
            // If the control is shown, that values overrides the ignoreScope app setting
            result = this.renderArea.down('#ignoreScopeControl').getValue();
        }
        else if (this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'workspace') {
            result = true;
        }
        return result;
    },

    _isSubscriber: function () {
        return this.isSubscriber;
    },

    _defaultPortfolioItemType: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.defaultPiType');
    },

    _propertyPrefix: function (typeName, piTypesAbove) {
        var property;
        if (typeName === 'hierarchicalrequirement' || typeName === 'userstory') {
            property = piTypesAbove[0].get('Name');
        }
        else if (typeName === 'defect') {
            property = 'Requirement.' + piTypesAbove[0].get('Name');
        }
        else if (Ext.String.startsWith(typeName, 'portfolioitem')) {
            property = 'Parent';
        }

        if (property) {
            // property already gets us to the lowest pi level above the current type
            // for each additional level, add a 'Parent' term, except for the last
            // type in the list which is the currently selected pi type ancestor
            _.forEach(piTypesAbove.slice(1), function () {
                property = property + '.Parent';
            }, this);
        }

        return property;
    },

    /**
     * Return a list of portfolio item types AT or below the selected pi type,
     * that are an ancestor of the given model, or null if there are no pi type
     * ancestors for the given model.
     */
    _piTypeAncestors: function (modelName, selectedPiTypePath) {
        var result = null;
        var selectedPiTypeIndex;
        var modelNamePiTypeIndex;

        if (_.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName)) {
            selectedPiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === selectedPiTypePath.toLowerCase();
            });
            result = this.portfolioItemTypes.slice(0, selectedPiTypeIndex + 1);
        }
        else if (Ext.String.startsWith(modelName, 'portfolioitem')) {
            modelNamePiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === modelName.toLowerCase();
            });
            selectedPiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === selectedPiTypePath.toLowerCase();
            });

            if (modelNamePiTypeIndex < selectedPiTypeIndex) {
                // Don't include the current model pi in the list of ancestors
                // Include the selcted pi type ancestor
                result = this.portfolioItemTypes.slice(modelNamePiTypeIndex + 1, selectedPiTypeIndex + 1);
            }
        }

        return result;
    },

    /*
        Multi-Level Filter functions
    */
    _showMultiLevelFilter: function () {
        return this.cmp.getSetting('Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter');
    },

    _addFilters: function () {
        return new Promise(function (resolve, reject) {
            var promises = [];
            if (this._showMultiLevelFilter() && !this._isSubscriber()) {
                if (this.btnRenderArea) {
                    if (!this._isSubscriber()) {
                        this.showFiltersBtn = this.btnRenderArea.add(
                            {
                                xtype: 'rallybutton',
                                cls: this.filtersHidden ? 'secondary' : 'primary' + ' rly-small',
                                iconCls: 'icon-filter',
                                toolTipText: + this.filtersHidden ? 'Show' : 'Hide' + ' Filters',
                                handler: this._toggleFilters,
                                scope: this
                            }
                        );

                        Rally.data.util.PortfolioItemHelper.getPortfolioItemTypes().then({
                            scope: this,
                            success: function (piTypes) {
                                this.piTypes = piTypes.reverse();
                                var piTypePaths = _.map(piTypes, function (piType) {
                                    return piType.get('TypePath');
                                });

                                this.models = Rally.data.ModelFactory.getModels({
                                    types: piTypePaths,
                                    context: this.cmp.getContext(),
                                    scope: this,
                                    success: function (models) {

                                        this.tabPanel = this.panelRenderArea.add({
                                            xtype: 'tabpanel',
                                            width: '98%',
                                            cls: 'blue-tabs',
                                            minTabWidth: 100,
                                            plain: true,
                                            autoRender: true,
                                            hidden: this._isSubscriber(),
                                            items: []
                                        });

                                        this.filterControls = [];

                                        _.each(models, function (model, key) {
                                            promises.push(new Promise(function (newResolve) {
                                                var filterName = `inlineFilter${key}`;
                                                this.filterControls.push(Ext.create('Rally.ui.inlinefilter.InlineFilterControl', {
                                                    xtype: 'rallyinlinefiltercontrol',
                                                    name: filterName,
                                                    stateful: true,
                                                    stateId: this.cmp.getContext().getScopedStateId(`multi-${filterName}-control`),
                                                    itemId: filterName,
                                                    context: this.cmp.getContext(),
                                                    inlineFilterButtonConfig: {
                                                        stateful: true,
                                                        stateId: this.cmp.getContext().getScopedStateId(`multi-${filterName}`),
                                                        context: this.cmp.getContext(),
                                                        modelNames: key,
                                                        filterChildren: this.filterChildren,
                                                        inlineFilterPanelConfig: {
                                                            name: `${filterName}-panel`,
                                                            itemId: `${filterName}-panel`,
                                                            model: model,
                                                            padding: 5,
                                                            width: '98%',
                                                            context: this.cmp.getContext(),
                                                            quickFilterPanelConfig: {
                                                                defaultFields: this.defaultFilterFields,
                                                                addQuickFilterConfig: {
                                                                    whiteListFields: this.whiteListFields,
                                                                    blackListFields: this.blackListFields
                                                                }
                                                            },
                                                            advancedFilterPanelConfig: {
                                                                collapsed: this.advancedFilterCollapsed,
                                                                advancedFilterRowsConfig: {
                                                                    propertyFieldConfig: {
                                                                        blackListFields: this.blackListFields,
                                                                        whiteListFields: this.whiteListFields
                                                                    }
                                                                }
                                                            },
                                                        },
                                                        listeners: {
                                                            inlinefilterchange: this._onFilterChange,
                                                            inlinefilterready: function (panel) {
                                                                this._onFilterReady(panel);
                                                                newResolve();
                                                            },
                                                            scope: this
                                                        }
                                                    }
                                                }));
                                            }.bind(this)));
                                        }, this);

                                        Promise.all(promises).then(function () {

                                            if (!this._isSubscriber()) {
                                                this.clearAllButton = Ext.widget({
                                                    xtype: 'rallybutton',
                                                    itemId: 'clearAllButton',
                                                    cls: 'secondary rly-small clear-all-filters-button',
                                                    text: 'Clear All',
                                                    margin: '3 9 3 0',
                                                    hidden: !this._hasFilters(),
                                                    listeners: {
                                                        click: this._clearAllFilters,
                                                        scope: this
                                                    }
                                                });

                                                this.btnRenderArea.add(this.clearAllButton);
                                                this.tabPanel.setActiveTab(0);
                                                if (this.filtersHidden) {
                                                    this.tabPanel.hide();
                                                }

                                                // Without this, the components are clipped on narrow windows
                                                this.btnRenderArea.setOverflowXY('auto', 'auto');
                                            }
                                            resolve();
                                        }.bind(this));
                                    },
                                    failure: function () {
                                        reject('Failed to fetch models for multi-level filter');
                                    }
                                });
                            },
                            failure: function () {
                                reject('Failed to fetch portfolio item types for multi-level filter');
                            }
                        });
                    }
                    else {
                        this.btnRenderArea.add({
                            xtype: 'container',
                            id: 'filterSubIndicatorArea',
                            width: 25,
                            padding: '6 5 0 0',
                            items: [
                                {
                                    xtype: 'component',
                                    id: 'subscriberFilterIndicator',
                                    html: '<span class="icon-link icon-large"></span>'
                                }
                            ]
                        });
                    }
                } else {
                    reject('Unable to find button render area for multi-level filter');
                }
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _clearAllFilters: function () {
        this.suspendEvents(false);
        this.suspendLayouts();

        _.each(this.filterControls, function (filterControl) {
            filterControl.inlineFilterButton.clearAllFilters();
        });

        if (this.clearAllButton) {
            this.clearAllButton.hide();
        }

        this.resumeEvents();
        this.resumeLayouts(false);
        this.updateLayout();
        this.fireEvent('change', this.getMultiLevelFilters());
    },

    _hasFilters: function () {
        var filters = this.getMultiLevelFilters();
        var returnVal = false;

        _.each(filters, function (filter) {
            if (filter.length) {
                returnVal = true;
            }
        });

        return returnVal;
    },

    _onFilterReady: function (panel) {
        panel.expand();
        let filterCount = panel.quickFilterPanel.getFilters().length + panel.advancedFilterPanel.getFilters().length;
        let modelName = (panel.model && panel.model.elementName) || 'unknown';

        let tab = this.tabPanel.add({
            title: modelName + (filterCount ? ` (${filterCount})` : ''),
            html: '',
            itemId: `${modelName}-tab`,

        });

        tab.add({
            xtype: 'container',
            layout: 'hbox',
            items: [panel]
        });
    },

    _applyFilters: function () {
        this.suspendEvents(false);
        this.suspendLayouts();
        _.each(this.filterControls, function (filterControl) {
            filterControl.inlineFilterButton._applyFilters();
        });
        this.resumeEvents();
        this.resumeLayouts(false);
        this.updateLayout();
    },

    _onFilterChange: function () {
        if (this.clearAllButton) {
            if (this._hasFilters()) {
                this.clearAllButton.show();
            }
            else {
                this.clearAllButton.hide();
            }
        }

        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.inlineFilterPanel.model.elementName) || 'unknown';
            this._setTabText(typeName, filterControl.inlineFilterButton.getFilters().length);
        }, this);

        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    _setTabText: function (typeName, filterCount) {
        var titleText = filterCount ? `${typeName} (${filterCount})` : typeName;
        var tab = this.tabPanel.child(`#${typeName}-tab`);

        if (tab) { tab.setTitle(titleText); }
    },

    _toggleFilters: function (btn) {
        if (this.tabPanel.isHidden()) {
            this.tabPanel.show();
            btn.setToolTipText('Hide Filters');
            btn.addCls('primary');
            btn.removeCls('secondary');
        } else {
            this.tabPanel.hide();
            btn.setToolTipText('Show Filters');
            btn.addCls('secondary');
            btn.removeCls('primary');
        }
    }
});
/* globals Rally */
// Fix the PreliminaryEstimate renderer to sort by value
Rally.ui.renderer.GridEditorFactory.editorRenderers['PreliminaryEstimate'] = function(field) {
    return {
        xtype: 'rallyrecordcontexteditor',
        field: {
            xtype: 'rallycombobox',
            allowNoEntry: !field.required,
            editable: false,
            name: field.name,
            storeConfig: {
                autoLoad: true,
                model: field.name,
                remoteFilter: true,
                sorters: [{
                    property: "Value"
                }],
                listeners: {
                    load: function() {
                        return;
                    }
                }
            }
        }
    };
};

Ext.define('Utils.AncestorPiInlineFilter', {
    override: 'Rally.ui.inlinefilter.QuickFilterPanel',
    portfolioItemTypes: [],
    modelName: undefined,
    customFilterNamePrefix: "AncestorPiInlineFilter.",

    _hasPiAncestor: function(modelName) {
        return _.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName) || Ext.String.startsWith(modelName, 'portfolioitem');
    },

    _pisAbove: function(modelName) {
        var result = [];
        if (_.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName)) {
            result = this.portfolioItemTypes
        }
        else if (Ext.String.startsWith(modelName, 'portfolioitem')) {
            var startIndex = _.findIndex(this.portfolioItemTypes, function(piType) {
                return piType.get('TypePath').toLowerCase() === modelName;
            });
            if (startIndex >= 0 && startIndex < this.portfolioItemTypes.length - 1) {
                result = this.portfolioItemTypes.slice(startIndex + 1);
            }
        }
        return result;
    },

    initComponent: function() {
        if (!this.dataContext) {
            this.dataContext = Rally.getApp().getContext().getDataContext();
        }

        if (this.modelName) {
            this.modelName = this.modelName.toLowerCase();
        }
        var filterFactoryOverrides = {};
        var additionalFields = []
        if (this._hasPiAncestor(this.modelName)) {
            var pisAbove = this._pisAbove(this.modelName);
            _.each(pisAbove, function(piType) {
                var typePath = piType.get('TypePath');
                var customFilterName = this.customFilterNamePrefix + typePath;
                var displayName = 'Portfolio Item / ' + piType.get('Name');
                filterFactoryOverrides[customFilterName] = {
                    xtype: 'ancestorpisearchcombobox',
                    portfolioItemType: typePath, // The artifact type to search for
                    piTypesAbove: pisAbove, // List of portfolio item types
                    artifactTypeName: this.modelName, // The artifact type we are filtering
                    storeConfig: {
                        context: this.dataContext,
                        models: typePath,
                        autoLoad: true
                    },
                    allowNoEntry: true,
                    noEntryValue: null,
                    noEntryText: 'No ' + displayName,
                    emptyText: 'Search ' + displayName + 's...',
                    allowClear: false,
                    valueField: 'ObjectUUID', // Must use ObjectUUID to align with the state that is saved by inlinefilterbutton
                    forceSelection: false
                };
                additionalFields.push({
                    name: customFilterName,
                    displayName: displayName
                })
            }, this);

            // Add the additional fields to the quick filter config
            _.merge(this.addQuickFilterConfig, {
                additionalFields: additionalFields
            }, function(a, b) {
                if (_.isArray(a)) {
                    return _.uniq(a.concat(b), 'name') // Strip duplicates by name that can occur from state
                }
            });

            // Add the corresponding items to the FilterFieldFactory
            Ext.override(Rally.ui.inlinefilter.FilterFieldFactory, filterFactoryOverrides);
        }

        this.callParent(arguments);
    },

    _createFields: function() {
        // Strip out the custom filters from this.fields and this.initialFilters
        this.fields = _.filter(this.fields, function(field) {
            return this._filterInvalidAncestorFilters(field);
        }, this);
        this.initialFilters = _.filter(this.initialFilters, function(filter) {
            return this._filterInvalidAncestorFilters(filter.name);
        }, this);
        this.callParent(arguments);
    },

    /**
     * This will exclude any field restored from state that we didn't explicitly add into the Factory
     * for the current model type. This prevents changes in model types from trying to build an invalid filter
     * for that new model type.
     */
    _filterInvalidAncestorFilters: function(name) {
        return !Ext.String.startsWith(name, this.customFilterNamePrefix) || Rally.ui.inlinefilter.FilterFieldFactory.hasOwnProperty(name)
    }
});

Ext.define('Utils.AncestorPiSearchComboBox', {
    alias: 'widget.ancestorpisearchcombobox',
    extend: 'Rally.ui.combobox.ArtifactSearchComboBox',

    parentField: 'PortfolioItem.Parent.',

    artifactTypeName: undefined, // The name of the model that will be filtered
    piTypesAbove: [],
    statics: {
        UUID_REGEX: /([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})/
    },

    constructor: function(config) {
        if (config.value) {
            Ext.merge(config, {
                storeConfig: {
                    filters: Rally.data.wsapi.Filter.or([{
                            property: config.valueField, // Compensate for parent constructor assuming that filter value is OidFromRef
                            value: config.value
                        }
                        /*, {
                                                property: 'ObjectID',
                                                operator: '!=',
                                                value: 0
                                            }*/
                    ])
                }
            });
        }

        //this.callSuper(arguments);
        // Get super super method (skip the extended ArtifactSearchComboBox.constructor()
        return this.superclass.superclass['constructor'].apply(this, arguments);
    },

    initComponent: function() {
        this.on('change', function(cmp, newValue, oldValue) {
            if (newValue == "") {
                this.store.load({
                    filters: []
                })
            }
        }, this)
        return this.callParent(arguments);
    },

    setValue: function() {
        this.callParent(arguments);
    },

    getFilter: function() {

        var value = this.lastValue;
        var propertyPrefix = this.propertyPrefix();
        var filters = []
        // If the value is a UUID, then use it, otherwise ignore values the user might be typing in
        if (value && this.statics().UUID_REGEX.test(value)) {
            filters.push({
                property: propertyPrefix + ".ObjectUUID",
                value: value
            });
        }
        else {
            filters.push({
                property: propertyPrefix,
                value: null
            });
        }
        return Rally.data.wsapi.Filter.or(filters);
    },

    propertyPrefix: function() {
        var property;
        // Get the path between the selected artifact and the lowest level PI above it
        if (this.artifactTypeName === 'hierarchicalrequirement' || this.artifactTypeName === 'userstory') {
            property = this.piTypesAbove[0].get('Name');
        }
        else if (this.artifactTypeName === 'defect') {
            property = 'Requirement.' + this.piTypesAbove[0].get('Name');
        }
        else if (Ext.String.startsWith(this.artifactTypeName, 'portfolioitem')) {
            property = 'Parent';
        }

        if (property) {
            // Now add .Parent for every PI level above the lowest until we get to the
            // desired PI type
            _.forEach(this.piTypesAbove, function(piType) {
                if (piType.get('TypePath').toLowerCase() == this.portfolioItemType.toLowerCase()) {
                    return false;
                }
                else {
                    property = property + '.Parent'
                }
            }, this);
        }

        return property;
    }
});

/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350, 
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        console.log("_checkChecksum", container);
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if (! app.isExternal() ) {
                
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger', {
    constructor: function(config) {
        Ext.apply(this, config);
    },
    log: function(args) {
        return; // disable logging for performance
    }

});

Ext.define('Rally.technicalservices.HierarchyExporter', {

    logger: new Rally.technicalservices.Logger(),
    mixins: {
        observable: 'Ext.util.Observable'
    },

    records: undefined,

    constructor: function(config) {
        this.mixins.observable.constructor.call(this, config);
        this.modelName = config.modelName;
        this.records = [];
        this.fileName = config.fileName || "export.csv";
        this.columns = config.columns || [{ dataIndex: 'FormattedID', text: 'ID' }, { dataIndex: 'Name', text: 'Name' }];
        this.portfolioItemTypeObjects = config.portfolioItemTypeObjects || [];
    },
    setRecords: function(type, records) {
        this.records = (this.records || []).concat(records);
    },
    export: function() {

        this.fireEvent('exportupdate', "Preparing export data");

        this.logger.log('export', this.records, this);

        var columns = this.columns,
            hierarchicalData = this._buildHierarchy(),
            exportData = this._getExportableHierarchicalData(hierarchicalData, columns);

        var ancestorType = this.modelName.toLowerCase();
        if (hierarchicalData.length > 0) {
            ancestorType = hierarchicalData[0]._type;
        }
        columns = this._getAncestorTypeColumns(ancestorType).concat(columns);

        var csv = this._transformDataToDelimitedString(exportData, columns);

        this.saveCSVToFile(csv, this.fileName);
        this.fireEvent('exportcomplete');

    },
    _buildHierarchy: function() {
        var rootItems = [];
        this.logger.log('_buildHierarchy', this.records.length);

        var objectHash = _.reduce(this.records, function(objHash, record) {
            var oid = record.get('ObjectID');
            objHash[oid] = record.getData();
            objHash[oid].loadedChildren = [];
            return objHash;
        }, {});

        this.logger.log('_buildhierarchy Hash', objectHash)

        this.records = null;

        for (var key in objectHash) {
            /*
             * guess at parent based on populated field.  it is
             * possible for an item to have two parents (e.g., a defect
             * might have a story and a test case related "above" it
             * this will default to the first it finds
             */
            var obj = objectHash[key],
                parent = obj.Parent && obj.Parent.ObjectID ||
                obj.PortfolioItem && obj.PortfolioItem.ObjectID ||
                obj.WorkProduct && obj.WorkProduct.ObjectID ||
                obj.Requirement && obj.Requirement.ObjectID ||
                obj.TestCase && obj.TestCase.ObjectID;

            //   if (obj._type === 'task') { console.log('obj',parent, obj._type, obj)};
            if (parent && objectHash[parent]) {
                objectHash[parent].loadedChildren.push(obj);
            }
            else {
                var grandParent = obj.Parent && obj.Parent.Parent && obj.Parent.Parent.ObjectID || null;
                if (grandParent && objectHash[grandParent]) {
                    objectHash[grandParent].loadedChildren.push(obj);
                }
                else {
                    rootItems.push(obj);
                }
            }
        }
        return rootItems;
    },
    _transformDataToDelimitedString: function(data, columns) {
        var csvArray = [],
            delimiter = ",",
            rowDelimiter = "\r\n",
            re = new RegExp(delimiter + '|\"|\r|\n', 'g'),
            reHTML = new RegExp('<\/?[^>]+>', 'g'),
            reNbsp = new RegExp('&nbsp;', 'ig');

        var column_keys = _.map(columns, function(c) { return c.dataIndex; }),
            column_headers = _.pluck(columns, 'text');

        csvArray.push(column_headers.join(delimiter));

        Ext.Array.each(data, function(obj) {
            var data = [];
            Ext.Array.each(column_keys, function(key) {
                var val = obj[key];
                //console.log('column-key', key, obj);
                if (key === "Parent") {
                    val = obj[key] || obj['PortfolioItem'];
                }

                if (val) {
                    if (reHTML.test(val)) {
                        val = val.replace('<br>', '\r\n');
                        this.logger.log('html val', val);
                        val = Ext.util.Format.htmlDecode(val);
                        val = Ext.util.Format.stripTags(val);
                        this.logger.log('stripped html val', val);
                    }
                    if (reNbsp.test(val)) {
                        val = val.replace(reNbsp, ' ');
                    }

                    if (re.test(val)) { //enclose in double quotes if we have the delimiters
                        val = val.replace(/\"/g, '\"\"');
                        val = Ext.String.format("\"{0}\"", val);
                    }

                }
                data.push(val);
            }, this);
            csvArray.push(data.join(delimiter));
        }, this);

        return csvArray.join(rowDelimiter);
    },
    /**
     * Returns an array of hash rollup data
     *
     * @param rootObjectIDs
     * @param columns - the data index of the columns that we want to export.
     * @param rollupData
     * @returns {Array}
     * @private
     */
    _getExportableHierarchicalData: function(hierarchyData, columns) {

        var exportData = [];

        _.each(hierarchyData, function(r) {
            var ancestors = {};
            var rec = this._getExportDataRow(r, columns, ancestors);
            exportData.push(rec);
            this._addExportChildren(r, exportData, columns, ancestors);
        }, this);

        return exportData;
    },
    _addExportChildren: function(record, exportData, columns, ancestors) {
        var new_ancestors = Ext.clone(ancestors),
            me = this;

        if (Ext.isEmpty(new_ancestors[record._type])) {
            new_ancestors[record._type] = record.FormattedID;
        }

        var children = record.loadedChildren;
        if (children && children.length > 0) {
            _.each(children, function(c) {
                var row = this._getExportDataRow(c, columns, new_ancestors);
                // if this is a descendant of a story, set the field that
                // represents the User Story column to be the first level
                // level story
                var child_type = row._type;
                if (!Ext.isEmpty(new_ancestors[child_type])) {
                    row[child_type] = new_ancestors[child_type];
                }
                exportData.push(row);
                me._addExportChildren(c, exportData, columns, new_ancestors);
            }, this);
        }

        return;
    },
    getTypePathDisplayName: function(modelName) {
        if (modelName.toLowerCase() === 'hierarchicalrequirement') {
            return 'User Story';
        }
        if (modelName.toLowerCase() === 'task') {
            return 'Task';
        }
        if (modelName.toLowerCase() === 'defect') {
            return 'Defect';
        }
        if (modelName.toLowerCase() === 'testcase') {
            return 'Test Case';
        }

        var displayName = '';
        Ext.Array.each(this.portfolioItemTypeObjects, function(p) {
            if (p.get('TypePath').toLowerCase() === modelName.toLowerCase()) {
                displayName = p.get('Name');
                return false;
            }
        });
        return displayName;
    },
    _getExportDataRow: function(recData, columns, ancestors) {
        var rec = Ext.clone(ancestors),
            type = recData._type; //obj.getData('type');

        rec[type] = recData.FormattedID;
        rec.type = this.getTypePathDisplayName(recData._type);
        rec._type = recData._type;

        _.each(columns, function(c) {
            var field = c.dataIndex || null;
            if (field) {
                var data = recData[field];

                if (field === "Parent") {
                    data = recData[field] || recData["PortfolioItem"];
                }

                if (Ext.isObject(data)) {
                    if (data._tagsNameArray && data._tagsNameArray.length > 0) {
                        var names = _.pluck(data._tagsNameArray, 'Name');
                        rec[field] = names.join(',');
                    }
                    else if (data.FormattedID) {
                        rec[field] = data.FormattedID + ": " + data._refObjectName;
                    }
                    else {
                        rec[field] = data._refObjectName;
                    }
                }
                else if (Ext.isDate(data)) {
                    rec[field] = Rally.util.DateTime.formatWithDefaultDateTime(data);
                }
                else {
                    rec[field] = data;
                }
            }
        });

        return rec;
    },
    _getAncestorTypeColumns: function(rootModel) {
        var modelName = rootModel.toLowerCase();
        var columns = [];
        if (modelName == 'hierarchicalrequirement' || Ext.String.startsWith(modelName, 'portfolioitem')) {
            var piTypes = this.portfolioItemTypeObjects,
                piIdx = -1;

            Ext.Array.each(piTypes, function(piObj, idx) {
                if (piObj.get('TypePath').toLowerCase() === rootModel.toLowerCase()) {
                    piIdx = idx;
                }
            });

            columns.push({
                dataIndex: 'hierarchicalrequirement',
                text: 'User Story'
            });

            if (piIdx >= 0) {
                columns = columns.concat(Ext.Array.map(piTypes.slice(0, piIdx + 1), function(piObj) {
                    return {
                        dataIndex: piObj.get('TypePath').toLowerCase(),
                        text: piObj.get('Name')
                    };
                }));
                columns.push({
                    dataIndex: 'type',
                    text: 'Artifact Type'
                });

            }
            columns.reverse();
        }
        return columns;
    },
    saveCSVToFile: function(csv, file_name, type_object) {
        if (type_object === undefined) {
            type_object = { type: 'text/csv;charset=utf-8' };
        }
        this.saveAs(csv, file_name, type_object);
    },
    saveAs: function(textToWrite, fileName) {
        if (Ext.isIE9m) {
            Rally.ui.notify.Notifier.showWarning({ message: "Export is not supported for IE9 and below." });
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], { type: 'text/plain' });
        }
        catch (e) {
            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder && e.name == 'TypeError') {
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob) {
            Rally.ui.notify.Notifier.showWarning({ message: "Export is not supported for this browser." });
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p) {
            window.navigator.msSaveOrOpenBlob(textFileAsBlob, fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url) {
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink) {
                downloadLink.download = fileNameToSaveAs;
            }
            else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome) {
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        }
        else {
            Rally.ui.notify.Notifier.showError({ message: "Export is not supported " });
        }

    },
    createObjectURL: function(file) {
        if (window.webkitURL) {
            return window.webkitURL.createObjectURL(file);
        }
        else if (window.URL && window.URL.createObjectURL) {
            return window.URL.createObjectURL(file);
        }
        else {
            return null;
        }
    },
    destroyClickedElement: function(event) {
        document.body.removeChild(event.target);
    }
});

Ext.define('Rally.technicalservices.HierarchyLoader', {
    logger: new Rally.technicalservices.Logger(),

    storyModelName: 'hierarchicalrequirement',
    taskModelName: 'task',

    mixins: {
        observable: 'Ext.util.Observable'
    },

    model: undefined,
    filters: undefined,
    fetch: undefined,
    childModels: undefined,
    sorters: undefined,

    maxParallelCalls: 6,

    constructor: function(config) {
        this.mixins.observable.constructor.call(this, config);
        this.portfolioItemTypes = config.portfolioItemTypes || [];
        this.model = config.model || null;
        this.fetch = config.fetch || [];
        this.filters = config.filters || [];
        this.loadChildModels = config.loadChildModels || [];
        this.sorters = config.sorters || [];
    },
    load: function() {

        if (!this.model) {
            this.fireEvent('hierarchyloaderror', "No model specified.");
            return;
        }
        if (this.portfolioItemTypes.length === 0) {
            this.fireEvent('hierarchyloaderror', "Portfolio Item Types not initialized.");
            return;
        }
        if (!(this.loadChildModels instanceof Array)) {
            this.fireEvent('hierarchyloaderror', "No child models specified.");
            return;
        }

        var fns = [];
        for (var i = 0; i < this.loadChildModels.length + 4; i++) {
            fns.push(this.fetchNextLevel);
        }

        Deft.Chain.pipeline(fns, this).then({
            success: function() {
                this.fireEvent('hierarchyloadcomplete');
            },
            failure: function(msg) {
                this.fireEvent('hierarchyloaderror', msg);
            },
            scope: this
        });
    },
    fetchNextLevel: function(args) {
        this.logger.log('fetchNextLevel', args, args && args.length);

        if (!args) {
            return this.fetchRoot();
        }

        args = _.flatten(args);
        this.logger.log('fetchNextLevel flattened args', args, args.length);

        if (args.length > 0 && Ext.isFunction(args[0].get)) {
            var type = args[0].get('_type');
            var types = Ext.Array.unique(Ext.Array.map(args, function(arg) { return arg.get('_type'); }));

            this.fireEvent('hierarchyloadartifactsloaded', type, args);

            var portfolioItemTypePaths = _.map(this.portfolioItemTypes, function(type) {
                    return type.get('TypePath').toLowerCase();
                }),
                portfolioItemOrdinal = _.indexOf(portfolioItemTypePaths, type);

            if (portfolioItemOrdinal === 0 && Ext.Array.contains(this.loadChildModels, this.storyModelName)) {
                return this.fetchUserStories(args);
            }
            if (portfolioItemOrdinal > 0 && Ext.Array.contains(this.loadChildModels, portfolioItemTypePaths[portfolioItemOrdinal - 1])) {
                return this.fetchPortfolioItems(portfolioItemTypePaths[portfolioItemOrdinal - 1], args);
            }

            return this.fetchChildrenFromMultipleTypes(types, args);
            // if (type === this.storyModelName ) {
            // this.getAllowedChildTypes(type);
            // return this.fetchTasks(args);
            //}
        }
        return [];
    },

    fetchRoot: function() {
        var fetch = this.fetch.concat(this.getRequiredFetchFields(this.model));
        this.fireEvent('statusupdate', "Loading artifacts");
        var config = {
            model: this.model,
            fetch: fetch,
            filters: this.filters,
            sorters: this.sorters,
            context: this.context
        };
        this.logger.log('fetchRoot config', config);

        return this.fetchWsapiRecords(config);
    },
    fetchPortfolioItems: function(type, parentRecords) {

        var fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'Children', 'Count');

        return this.fetchChunks(type, fetch, chunks, "Parent.ObjectID", Ext.String.format("Please Wait... Loading Children for {0} Portfolio Items", parentRecords.length));
    },
    _getChunks: function(parentRecords, countField, countFieldAttribute) {
        this.logger.log("_getChunks", parentRecords, countField, countFieldAttribute);

        var chunks = [],
            childCount = 0,
            maxListSize = 100,
            childCountTarget = 200,
            idx = 0;

        chunks[idx] = [];
        _.each(parentRecords, function(r) {
            var count = r.get(countField);
            if (countFieldAttribute && count) {
                count = count[countFieldAttribute];
            }
            if (count > 0) { //using story count because it is a more accurate gauge of the number of user stories for a feature than UserStories.Count is, evne though it may not match exactly.
                childCount += count;
                if (childCount > childCountTarget || chunks[idx].length >= maxListSize) {
                    idx++;
                    chunks[idx] = [];
                    childCount = 0;
                }
                chunks[idx].push(r.get('ObjectID'));
            }
        });

        return chunks;
    },
    fetchUserStories: function(parentRecords) {
        var type = this.storyModelName,
            fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'LeafStoryCount'),
            featureParentName = this.portfolioItemTypes[0].get('Name').replace(/\s/g, '') + ".ObjectID";

        return this.fetchChunks(type, fetch, chunks, featureParentName, Ext.String.format("Please Wait... Loading User Stories for {0} Portfolio Items", parentRecords.length));
    },

    fetchChildrenFromMultipleTypes: function(types, parentRecords) {
        this.logger.log('fetchChildrenFromMultipleTypes', types, parentRecords);

        var promises = [];
        Ext.Array.map(types, function(type) {
            child_types = this.getAllowedChildTypes(type);
            if (child_types.length > 0) {
                var parents = Ext.Array.filter(parentRecords, function(parent) {
                    return (parent.get('_type') == type);
                }, this);
                promises.push(function() {
                    return this.fetchChildrenOfMultipleTypes(parents);
                });
            }
        }, this);

        if (promises.length === 0) { return []; }
        return Deft.Chain.sequence(promises, this);
    },
    fetchChildrenOfMultipleTypes: function(parentRecords) {
        var parent_type = parentRecords[0].get('_type');
        var child_types = this.getAllowedChildTypes(parent_type);
        this.logger.log('fetchChildrenOfMultipleTypes', child_types, parentRecords);
        var promises = Ext.Array.map(child_types, function(type) {
            return function() { return this.fetchChildren(type, parentRecords); }
        }, this);

        return Deft.Chain.sequence(promises, this);
    },

    fetchChildren: function(type, parentRecords) {
        this.logger.log("fetchChildren", type, parentRecords);
        var fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            parentType = parentRecords[0].get('_type'),
            childField = this.getChildFieldFor(parentType, type),
            chunks = this._getChunks(parentRecords, childField, 'Count'),
            parentField = this.getParentFieldFor(type, parentType);

        return this.fetchChunks(type, fetch, chunks, parentField + ".ObjectID",
            Ext.String.format("Please Wait... Loading {0} for {1} items", childField, parentRecords.length));
    },

    // fetchTasks: function(parentRecords){
    //     var type = this.taskModelName,
    //         fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
    //         chunks = this._getChunks(parentRecords, 'Tasks', 'Count');
    //
    //     return this.fetchChunks(type, fetch, chunks, "WorkProduct.ObjectID", Ext.String.format("Please Wait... Loading Tasks for {0} User Stories", parentRecords.length));
    // },
    fetchChunks: function(type, fetch, chunks, chunkProperty, statusString) {
        this.logger.log('fetchChunks', fetch, chunkProperty, chunks);

        if (!chunks || chunks.length === 0) {
            return [];
        }
        if (chunks[0].length === 0) {
            return [];
        }

        this.fireEvent('statusupdate', statusString);

        var promises = [];
        _.each(chunks, function(c) {
            var filters = _.map(c, function(ids) { return { property: chunkProperty, value: ids }; }),
                config = {
                    model: type,
                    fetch: fetch,
                    sorters: [
                        { property: 'TaskIndex', direction: 'ASC' },
                        { property: 'DragAndDropRank', direction: 'ASC' }
                    ],
                    filters: Rally.data.wsapi.Filter.or(filters),
                    context: { project: null }
                };
            promises.push(function() { return this.fetchWsapiRecords(config); });
        });

        return this.throttle(promises, this.maxParallelCalls, this);
    },
    fetchWsapiRecords: function(config) {
        var deferred = Ext.create('Deft.Deferred');

        config.compact = false;
        config.limit = "Infinity";
        config.allowPostGet = true;

        Ext.create('Rally.data.wsapi.Store', config).load({
            callback: function(records, operation) {
                if (operation.wasSuccessful()) {
                    deferred.resolve(records);
                }
                else {
                    deferred.reject('fetchWsapiRecords error: ' + operation.error.errors.join(','));
                }
            },
            scope: this
        });
        return deferred;
    },

    getChildFieldFor: function(parent_type, child_type) {
        if (parent_type.toLowerCase() === "hierarchicalrequirement" || parent_type.toLowerCase() === "userstory") {
            if (child_type.toLowerCase() == "task") { return 'Tasks'; }
            if (child_type.toLowerCase() == "defect") { return 'Defects'; }
            if (child_type.toLowerCase() == "testcase") { return 'TestCases'; }
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'Children'; }
        }
        if (parent_type.toLowerCase() === "defect") {
            if (child_type.toLowerCase() == "task") { return 'Tasks'; }
            if (child_type.toLowerCase() == "testcase") { return 'TestCases'; }
        }
        if (parent_type.toLowerCase() === "testcase") {
            if (child_type.toLowerCase() == "defect") { return 'Defects'; }
        }
        if (/portfolioitem/.test(parent_type.toLowerCase())) {
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'UserStories'; }
        }
        return null;
    },

    getParentFieldFor: function(child_type, parent_type) {
        if (parent_type.toLowerCase() === "hierarchicalrequirement" || parent_type.toLowerCase() === "userstory") {
            if (child_type.toLowerCase() == "task") { return 'WorkProduct'; }
            if (child_type.toLowerCase() == "defect") { return 'Requirement'; }
            if (child_type.toLowerCase() == "testcase") { return 'WorkProduct'; }
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'Parent'; }
        }
        if (parent_type.toLowerCase() === "defect") {
            if (child_type.toLowerCase() == "task") { return 'WorkProduct'; }
            if (child_type.toLowerCase() == "testcase") { return 'WorkProduct'; }
        }
        if (parent_type.toLowerCase() === "testcase") {
            if (child_type.toLowerCase() == "defect") { return 'TestCase'; }
        }
        if (/portfolioitem/.test(parent_type.toLowerCase())) {
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'PortfolioItem'; }
        }
        return null;

    },
    getAllowedChildTypes: function(type) {
        var allowed_types = [];
        var given_types = this.loadChildModels;

        if (type.toLowerCase() === this.storyModelName.toLowerCase()) {
            allowed_types = ['task', 'defect', 'testcase', this.storyModelName.toLowerCase()];
        }
        if (type.toLowerCase() === 'defect') {
            allowed_types = ['task', 'testcase'];
        }
        if (type.toLowerCase() === 'testcase') {
            allowed_types = ['defect'];
        }

        var types_in_both = Ext.Array.intersect(allowed_types, given_types);
        return types_in_both;
    },

    getRequiredFetchFields: function(type) {
        if (/^portfolioitem/.test(type.toLowerCase())) {
            return ['Children', 'LeafStoryCount', 'Parent', 'ObjectID', 'UserStories'];
        }

        if (type.toLowerCase() === this.storyModelName) {
            return ['FormattedID', 'Children', 'Tasks', 'Parent', 'PortfolioItem', 'HasParent', 'ObjectID', 'TestCases', 'Defects'];
        }

        return ['ObjectID', 'WorkProduct', 'Defects', 'Tasks', 'TestCases', 'Requirement', 'TestCase', 'FormattedID'];
    },
    throttle: function(fns, maxParallelCalls, scope) {

        if (maxParallelCalls <= 0 || fns.length < maxParallelCalls) {
            return Deft.promise.Chain.parallel(fns, scope);
        }


        var parallelFns = [],
            fnChunks = [],
            idx = -1;

        for (var i = 0; i < fns.length; i++) {
            if (i % maxParallelCalls === 0) {
                idx++;
                fnChunks[idx] = [];
            }
            fnChunks[idx].push(fns[i]);
        }

        _.each(fnChunks, function(chunk) {
            parallelFns.push(function() {
                return Deft.promise.Chain.parallel(chunk, scope);
            });
        });

        return Deft.Promise.reduce(parallelFns, function(groupResults, fnGroup) {
            return Deft.Promise.when(fnGroup.call(scope)).then(function(results) {
                groupResults = groupResults.concat(results || []);
                return groupResults;
            });
        }, []);
    }

});

// Remove 'Actuals' from the blacklist
Ext.override(Rally.ui.gridboard.plugin.GridBoardFieldPicker, {
    gridFieldBlackList: [
        // 'Actuals',
        'Changesets',
        'Children',
        // 'Description',
        // 'Notes',
        'ObjectID',
        'Predecessors',
        'RevisionHistory',
        'Subscription',
        'Successors',
        'TaskIndex',
        'Workspace',
        'VersionId'
    ]
});

Ext.override(Rally.ui.inlinefilter.PropertyFieldComboBox, {
    /**
     * @cfg {String[]} whiteListFields
     * field names that should be included from the filter row field combobox
     */
    defaultWhiteListFields: ['Milestones', 'Tags']
});

Ext.override(Rally.ui.grid.TreeGrid, {
    // Override needed to allow summaryType to be restored when a column with
    // summaryType config is added by the field picker
    _mergeColumnConfigs: function(newColumns, oldColumns) {
        return _.map(newColumns, function(newColumn) {
            // If the newly selected column is currently in oldColumns (this.columns), then
            // use the in-use column config to preserve its current settings
            var result = newColumn;
            var newColumnName = this._getColumnName(newColumn);
            var oldColumn = _.find(oldColumns, { dataIndex: newColumnName });
            if (oldColumn) {
                result = this._getColumnConfigFromColumn(oldColumn);
            }
            else if (this.config && this.config.columnCfgs) {
                // Otherwise, if the newly selected column appears in the original columnCfgs
                // use that config. (This allows the column picker to get any renderers or summary
                // config from the column config)
                var columnCfg = _.find(this.config.columnCfgs, { dataIndex: newColumnName });
                if (columnCfg) {
                    result = columnCfg;
                }
            }

            return result;
        }, this);
    },

    // Override needed to allow summaryType to be included when a column is restored
    // from state.
    _applyStatefulColumns: function(columns) {
        // TODO (tj) test default columns
        if (this.alwaysShowDefaultColumns) {
            _.each(this.columnCfgs, function(columnCfg) {
                if (!_.any(columns, { dataIndex: this._getColumnName(columnCfg) })) {
                    columns.push(columnCfg);
                }
            }, this);
        }

        if (this.config && this.config.columnCfgs) {
            // Merge the column config with the stateful column if the dataIndex is the same.
            // This allows use to pick up summaryType and custom renderers
            _.each(this.config.columnCfgs, function(columnCfg) {
                // Search by dataIndex or text
                var columnName = this._getColumnName(columnCfg);
                var columnState = _.find(columns, function(value) {
                    return (value.dataIndex === columnName || value.text === columnName);
                });
                if (columnState) {
                    // merge them (add renderer)
                    _.merge(columnState, columnCfg);
                }
            }, this);
        }

        this.columnCfgs = columns;
    }
});

(function() {
    var Ext = window.Ext4 || window.Ext;

    var getHiddenFieldConfig = function(name) {
        return {
            name: name,
            xtype: 'rallytextfield',
            hidden: true,
            handlesEvents: {
                typeselected: function(type) {
                    this.setValue(null);
                }
            }
        };
    };

    Ext.define('Rally.technicalservices.CustomGridWithDeepExportSettings', {
        singleton: true,
        requires: [
            'Rally.ui.combobox.FieldComboBox',
            'Rally.ui.combobox.ComboBox',
            'Rally.ui.CheckboxField'
        ],

        getFields: function() {

            var type_filters = Rally.data.wsapi.Filter.or([
                { property: 'TypePath', value: 'HierarchicalRequirement' },
                { property: 'TypePath', operator: 'contains', value: 'PortfolioItem/' }
            ]);

            return [{
                    name: 'type',
                    xtype: 'rallycombobox',
                    allowBlank: false,
                    autoSelect: false,
                    shouldRespondToScopeChange: true,
                    initialValue: 'HierarchicalRequirement',
                    storeConfig: {
                        model: Ext.identityFn('TypeDefinition'),
                        sorters: [{ property: 'DisplayName' }],
                        fetch: ['DisplayName', 'ElementName', 'TypePath', 'Parent', 'UserListable'],
                        //filters: type_filters,
                        filters: [{ property: 'UserListable', value: true }],
                        autoLoad: false,
                        remoteSort: false,
                        remoteFilter: true
                    },
                    displayField: 'DisplayName',
                    valueField: 'TypePath',
                    listeners: {
                        select: function(combo) {
                            combo.fireEvent('typeselected', combo.getRecord().get('TypePath'), combo.context);
                        }
                    },
                    bubbleEvents: ['typeselected'],
                    readyEvent: 'ready',
                    handlesEvents: {
                        projectscopechanged: function(context) {
                            this.refreshWithNewContext(context);
                        }
                    }
                },
                { type: 'query' },
                {
                    name: 'showControls',
                    xtype: 'rallycheckboxfield',
                    fieldLabel: 'Show Control Bar'
                },
                {
                    name: 'enableUrlSharing',
                    xtype: 'rallycheckboxfield',
                    fieldLabel: 'Enable URL Sharing of Saved Views'
                },
                getHiddenFieldConfig('columnNames'),
                getHiddenFieldConfig('order')
            ];
        }
    });
})();

Ext.define('custom-grid-with-deep-export', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    items: [{
        id: Utils.AncestorPiAppFilter.RENDER_AREA_ID,
        xtype: 'container',
        layout: {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 10 0',
        }
    }, {
        id: Utils.AncestorPiAppFilter.PANEL_RENDER_AREA_ID,
        xtype: 'container',
        layout: {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 10 0',
        }
    }, {
        id: 'grid-area',
        xtype: 'container',
        flex: 1,
        type: 'vbox',
        align: 'stretch'
    }],
    config: {
        defaultSettings: {
            columnNames: ['FormattedID', 'Name', 'ScheduleState'],
            query: '',
            showControls: true,
            type: 'HierarchicalRequirement',
            pageSize: 50,
            enableUrlSharing: false
        }
    },

    integrationHeaders: {
        name: 'custom-grid-with-deep-export'
    },

    disallowedAddNewTypes: ['user', 'userprofile', 'useriterationcapacity', 'testcaseresult', 'task', 'scmrepository', 'project', 'changeset', 'change', 'builddefinition', 'build', 'program'],
    orderedAllowedPageSizes: [10, 25, 50, 100, 200],
    readOnlyGridTypes: ['build', 'change', 'changeset'],
    statePrefix: 'customlist',
    allowExpansionStateToBeSaved: false,
    enableAddNew: true,
    onTimeboxScopeChange(newTimeboxScope) {
        this.callParent(arguments);
        this._buildStore();
    },
    launch() {
        Rally.data.wsapi.Proxy.superclass.timeout = 240000;
        Rally.data.wsapi.batch.Proxy.superclass.timeout = 240000;
        this.ancestorFilterPlugin = Ext.create('Utils.AncestorPiAppFilter', {
            ptype: 'UtilsAncestorPiAppFilter',
            pluginId: 'ancestorFilterPlugin',
            settingsConfig: {},
            whiteListFields: [
                'Tags',
                'Milestones'
            ],
            filtersHidden: false,
            listeners: {
                scope: this,
                ready(plugin) {
                    Rally.data.util.PortfolioItemHelper.getPortfolioItemTypes().then({
                        scope: this,
                        success(portfolioItemTypes) {
                            this.portfolioItemTypes = _.sortBy(portfolioItemTypes, type => type.get('Ordinal'));

                            plugin.addListener({
                                scope: this,
                                select: this.viewChange,
                                change: this.viewChange
                            });
                            this.viewChange();
                        },
                        failure(msg) {
                            this._showError(msg);
                        },
                    });
                },
            }
        });
        this.addPlugin(this.ancestorFilterPlugin);
    },

    // Usual monkey business to size gridboards
    onResize() {
        this.callParent(arguments);
        let gridArea = this.down('#grid-area');
        let gridboard = this.down('rallygridboard');
        if (gridArea && gridboard) {
            gridboard.setHeight(gridArea.getHeight());
        }
    },

    _buildStore() {
        this.modelNames = [this.getSetting('type')];
        this.logger.log('_buildStore', this.modelNames);
        let fetch = ['FormattedID', 'Name'];
        let dataContext = this.getContext().getDataContext();
        if (this.searchAllProjects()) {
            dataContext.project = null;
        }

        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: this.modelNames,
            enableHierarchy: true,
            remoteSort: true,
            fetch,
            context: dataContext
        }).then({
            success: this._addGridboard,
            scope: this
        });
    },
    _addGridboard(store) {
        let gridArea = this.down('#grid-area');
        gridArea.removeAll();

        let currentModelName = this.modelNames[0];

        let filters = this.getSetting('query') ? [Rally.data.wsapi.Filter.fromQueryString(this.getSetting('query'))] : [];
        let timeboxScope = this.getContext().getTimeboxScope();
        if (timeboxScope && timeboxScope.isApplicable(store.model)) {
            filters.push(timeboxScope.getQueryFilter());
        }

        filters = filters.concat(this.ancestorFilterPlugin.getAllFiltersForType(currentModelName));

        this.logger.log('_addGridboard', store);

        let context = this.getContext();
        let dataContext = context.getDataContext();
        if (this.searchAllProjects()) {
            dataContext.project = null;
        }
        let summaryRowFeature = Ext.create('Rally.ui.grid.feature.SummaryRow');
        this.gridboard = gridArea.add({
            xtype: 'rallygridboard',
            context,
            modelNames: this.modelNames,
            toggleState: 'grid',
            height: gridArea.getHeight(),
            listeners: {
                scope: this,
                viewchange: this.viewChange,
            },
            plugins: [
                'rallygridboardaddnew',
                {
                    ptype: 'rallygridboardinlinefiltercontrol',
                    inlineFilterButtonConfig: {
                        stateful: false,
                        modelNames: this.modelNames,
                        hidden: true,
                        inlineFilterPanelConfig: {
                            hidden: true,
                            quickFilterPanelConfig: {
                                portfolioItemTypes: this.portfolioItemTypes,
                                modelName: currentModelName,
                                whiteListFields: [
                                    'Tags',
                                    'Milestones'
                                ]
                            }
                        }
                    }
                },
                {
                    ptype: 'rallygridboardfieldpicker',
                    headerPosition: 'left',
                    modelNames: this.modelNames,
                    stateful: true,
                    stateId: this.getModelScopedStateId(currentModelName, 'fields'),
                    margin: '3 10 0 10'
                },
                {
                    ptype: 'rallygridboardactionsmenu',
                    menuItems: this._getExportMenuItems(),
                    buttonConfig: {
                        iconCls: 'icon-export'
                    }
                },
                {
                    ptype: 'rallygridboardsharedviewcontrol',
                    sharedViewConfig: {
                        enableUrlSharing: this.getSetting('enableUrlSharing'),
                        stateful: true,
                        stateId: this.getModelScopedStateId(currentModelName, 'views'),
                        stateEvents: ['select', 'beforedestroy']
                    },
                }
            ],
            cardBoardConfig: {
                attribute: 'ScheduleState'
            },
            gridConfig: {
                store,
                storeConfig: {
                    filters,
                    context: dataContext
                },
                columnCfgs: [
                    'Name',
                    {
                        dataIndex: 'PlanEstimate',
                        summaryType: 'sum'
                    },
                    {
                        dataIndex: 'TaskRemainingTotal',
                        summaryType: 'sum'
                    },
                    {
                        dataIndex: 'ToDo',
                        summaryType: 'sum'
                    },
                    {
                        dataIndex: 'TaskEstimateTotal',
                        summaryType: 'sum'
                    }
                ],
                features: [summaryRowFeature]
            }
        });
    },

    viewChange() {
        this._buildStore();
    },

    getModelScopedStateId(modelName, id) {
        return this.getContext().getScopedStateId(`${modelName}-${id}`);
    },

    _getExportMenuItems() {
        let result = [];
        this.logger.log('_getExportMenuItems', this.modelNames[0]);
        let currentModel = this.modelNames[0].toLowerCase();
        if (currentModel === 'hierarchicalrequirement') {
            result = [{
                text: 'Export User Stories...',
                handler: this._export,
                scope: this,
                childModels: ['hierarchicalrequirement']
            }, {
                text: 'Export User Stories and Tasks...',
                handler: this._export,
                scope: this,
                childModels: ['hierarchicalrequirement', 'task']
            }, {
                text: 'Export User Stories and Child Items...',
                handler: this._export,
                scope: this,
                childModels: ['hierarchicalrequirement', 'task', 'defect', 'testcase']
            }];
        } else if (Ext.String.startsWith(currentModel, 'portfolioitem')) {
            let piTypeNames = this.getPortfolioItemTypeNames();
            let idx = _.indexOf(piTypeNames, currentModel);
            let childModels = [];
            if (idx > 0) {
                for (let i = idx; i > 0; i--) {
                    childModels.push(piTypeNames[i - 1]);
                }
            }

            result = [{
                text: 'Export Portfolio Items...',
                handler: this._export,
                scope: this,
                childModels
            }, {
                text: 'Export Portfolio Items and User Stories...',
                handler: this._export,
                scope: this,
                childModels: childModels.concat(['hierarchicalrequirement'])
            }, {
                text: 'Export Portfolio Items, User Stories and Tasks...',
                handler: this._export,
                scope: this,
                childModels: childModels.concat(['hierarchicalrequirement', 'task'])
            }, {
                text: 'Export Portfolio Items and Child Items...',
                handler: this._export,
                scope: this,
                childModels: childModels.concat(['hierarchicalrequirement', 'task', 'defect', 'testcase'])
            }];
        } else if (currentModel == 'defect') {
            result = [{
                text: 'Export Defects...',
                handler: this._export,
                scope: this,
                childModels: []
            }, {
                text: 'Export Defects and Child Items...',
                handler: this._export,
                scope: this,
                childModels: ['defect', 'task', 'testcase']
            }];
        } else if (currentModel == 'testcase') {
            result = [{
                text: 'Export Test Cases...',
                handler: this._export,
                scope: this,
                childModels: []
            }, {
                text: 'Export Test Cases and Child Items...',
                handler: this._export,
                scope: this,
                childModels: ['defect', 'task', 'testcase']
            }];
        } else {
            result = [{
                text: 'Export to CSV...',
                handler: this._export,
                scope: this,
                childModels: []
            }];
        }

        return result;
    },
    getPortfolioItemTypeNames() {
        return _.map(this.portfolioItemTypes, type => type.get('TypePath').toLowerCase());
    },

    _showError(msg) {
        Rally.ui.notify.Notifier.showError({ message: msg });
    },
    _showStatus(message) {
        this.logger.log('_showstatus', message, this);
        if (message) {
            Rally.ui.notify.Notifier.showStatus({
                message,
                showForever: true,
                closable: false,
                animateShowHide: false
            });
        } else {
            Rally.ui.notify.Notifier.hide();
        }
    },
    _getExportColumns() {
        let grid = this.down('rallygridboard').getGridOrBoard();
        if (grid) {
            return _.filter(grid.columns, item => (
                item.dataIndex &&
                item.dataIndex != 'DragAndDropRank' &&
                item.xtype &&
                item.xtype != 'rallytreerankdraghandlecolumn' &&
                item.xtype != 'rallyrowactioncolumn' &&
                item.text != '&#160;'));
        }
        return [];
    },
    _getExportFilters() {
        let grid = this.down('rallygridboard'),
            filters = [],
            query = this.getSetting('query');

        if (grid.currentCustomFilter && grid.currentCustomFilter.filters) {
            // Concat any current custom filters (don't assign as we don't want to modify the currentCustomFilter array)
            filters = filters.concat(grid.currentCustomFilter.filters);
        }

        if (query) {
            filters.push(Rally.data.wsapi.Filter.fromQueryString(query));
        }

        let timeboxScope = this.getContext().getTimeboxScope();
        if (timeboxScope && timeboxScope.isApplicable(grid.getGridOrBoard().store.model)) {
            filters.push(timeboxScope.getQueryFilter());
        }

        filters = filters.concat(this.ancestorFilterPlugin.getAllFiltersForType(this.modelNames[0]));

        return filters;
    },
    _getExportFetch() {
        let fetch = _.pluck(this._getExportColumns(), 'dataIndex');
        if (Ext.Array.contains(fetch, 'TaskActualTotal')) {
            fetch.push('Actuals');
        }
        return fetch;
    },
    _getExportSorters() {
        return this.down('rallygridboard').getGridOrBoard().getStore().getSorters();
    },
    _export(args) {
        let columns = this._getExportColumns(),
            fetch = this._getExportFetch(),
            filters = this._getExportFilters(),
            modelName = this.modelNames[0],
            childModels = args.childModels,
            sorters = this._getExportSorters();

        this.logger.log('_export', fetch, args, columns, filters.toString(), childModels, sorters);

        let exporter = Ext.create('Rally.technicalservices.HierarchyExporter', {
            modelName,
            fileName: 'hierarchy-export.csv',
            columns,
            portfolioItemTypeObjects: this.portfolioItemTypes

        });
        exporter.on('exportupdate', this._showStatus, this);
        exporter.on('exporterror', this._showError, this);
        exporter.on('exportcomplete', this._showStatus, this);

        let dataContext = this.getContext().getDataContext();
        if (this.searchAllProjects()) {
            dataContext.project = null;
        }
        let hierarchyLoader = Ext.create('Rally.technicalservices.HierarchyLoader', {
            model: modelName,
            fetch,
            filters,
            sorters,
            loadChildModels: childModels,
            portfolioItemTypes: this.portfolioItemTypes,
            context: dataContext
        });
        hierarchyLoader.on('statusupdate', this._showStatus, this);
        hierarchyLoader.on('hierarchyloadartifactsloaded', exporter.setRecords, exporter);
        hierarchyLoader.on('hierarchyloadcomplete', exporter.export, exporter);
        hierarchyLoader.on('hierarchyloaderror', this._showError, this);
        hierarchyLoader.load();
    },
    getHeight() {
        let el = this.getEl();
        if (el) {
            let height = this.callParent(arguments);
            return Ext.isIE8 ? Math.max(height, 600) : height;
        }

        return 0;
    },

    setHeight(height) {
        this.callParent(arguments);
        if (this.gridboard) {
            this.gridboard.setHeight(height);
        }
    },
    getOptions() {
        return [{
            text: 'About...',
            handler: this._launchInfo,
            scope: this
        }];
    },

    _launchInfo() {
        if (this.about_dialog) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink', {});
    },

    isExternal() {
        return typeof (this.getAppId()) === 'undefined';
    },

    searchAllProjects() {
        return this.ancestorFilterPlugin.getIgnoreProjectScope();
    },

    getSettingsFields() {
        return Rally.technicalservices.CustomGridWithDeepExportSettings.getFields();
    }
});


               Rally.launchApp('custom-grid-with-deep-export', {
                   name: 'custom-grid-with-deep-export'
               });
        });
    </script>

    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
.blue-tabs .x-tab-bar .x-tab-default {
    background-color: white;
    border-radius: 4px 4px 0 0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
    color: #00a9e0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-active {
    background-color: #00a9e0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-active .x-tab-inner {
    color: white;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
    text-overflow: initial;
    -o-text-overflow: initial;
    overflow: initial;
  }
  
  .blue-tabs .x-tab-bar .x-tab-inner {
    width: 100%;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-icon-el {
    color: white;
  }
    </style>

</head>
<body></body>
</html>